#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
/* automatically generated by rust-bindgen 0.59.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 28;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _SYS_UIO_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const UIO_MAXIOV: u32 = 1024;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const EF_VI_DMA_ALIGN: u32 = 64;
pub const EF_VI_MAX_QS: u32 = 32;
pub const EF_VI_EVENT_POLL_MIN_EVS: u32 = 2;
pub const EF_REQUEST_ID_MASK: u32 = 4294967295;
pub const EF_EVENT_FLAG_SOP: u32 = 1;
pub const EF_EVENT_FLAG_CONT: u32 = 2;
pub const EF_EVENT_FLAG_ISCSI_OK: u32 = 4;
pub const EF_EVENT_FLAG_MULTICAST: u32 = 8;
pub const EF_EVENT_FLAG_PS_NEXT_BUFFER: u32 = 16;
pub const EF_EVENT_FLAG_CTPIO: u32 = 1;
pub const EF_VI_SYNC_FLAG_CLOCK_SET: u32 = 1;
pub const EF_VI_SYNC_FLAG_CLOCK_IN_SYNC: u32 = 2;
pub const EF_EVENT_TX_WITH_TIMESTAMP_SYNC_MASK: u32 = 3;
pub const EF_EVENT_SW_DATA_MASK: u32 = 65535;
pub const EF_EVENT_FMT: &'static [u8; 8usize] = b"[ev:%x]\0";
pub const EF_VI_RECEIVE_BATCH: u32 = 15;
pub const EF_VI_TRANSMIT_BATCH: u32 = 64;
pub const EF_VI_CTPIO_CT_THRESHOLD_SNF: u32 = 65535;
pub const EF_VI_NIC_PAGE_SHIFT: u32 = 12;
pub const EF_VI_NIC_PAGE_SIZE: u32 = 4096;
pub const EF_ADDR_FMT: &'static [u8; 2usize] = b"%\0";
pub const EF_PD_VLAN_NONE: i32 = -1;
pub const EF_VI_CONFIG_PIO: u32 = 1;
pub const ZF_CACHE_LINE_SIZE: u32 = 64;
pub const ZF_FLEXIBLE_ARRAY_COUNT: u32 = 0;
pub const _SYS_EPOLL_H: u32 = 1;
pub const EPOLL_CTL_ADD: u32 = 1;
pub const EPOLL_CTL_DEL: u32 = 2;
pub const EPOLL_CTL_MOD: u32 = 3;
pub const ZF_EPOLLIN_OVERLAPPED: u32 = 65536;
pub const _NETINET_IN_H: u32 = 1;
pub const _SYS_SOCKET_H: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MAX: u32 = 45;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MAX: u32 = 45;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOMAXCONN: u32 = 128;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP: u32 = 35078;
pub const SIOCGSTAMPNS: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SO_MARK: u32 = 36;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const __osockaddr_defined: u32 = 1;
pub const __USE_KERNEL_IPV6_DEFS: u32 = 0;
pub const IP_OPTIONS: u32 = 4;
pub const IP_HDRINCL: u32 = 3;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IP: u32 = 0;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const __NETINET_IP_H: u32 = 1;
pub const IP_RF: u32 = 32768;
pub const IP_DF: u32 = 16384;
pub const IP_MF: u32 = 8192;
pub const IP_OFFMASK: u32 = 8191;
pub const IPVERSION: u32 = 4;
pub const IP_MAXPACKET: u32 = 65535;
pub const IPTOS_ECN_MASK: u32 = 3;
pub const IPTOS_ECN_NOT_ECT: u32 = 0;
pub const IPTOS_ECN_ECT1: u32 = 1;
pub const IPTOS_ECN_ECT0: u32 = 2;
pub const IPTOS_ECN_CE: u32 = 3;
pub const IPTOS_DSCP_MASK: u32 = 252;
pub const IPTOS_DSCP_AF11: u32 = 40;
pub const IPTOS_DSCP_AF12: u32 = 48;
pub const IPTOS_DSCP_AF13: u32 = 56;
pub const IPTOS_DSCP_AF21: u32 = 72;
pub const IPTOS_DSCP_AF22: u32 = 80;
pub const IPTOS_DSCP_AF23: u32 = 88;
pub const IPTOS_DSCP_AF31: u32 = 104;
pub const IPTOS_DSCP_AF32: u32 = 112;
pub const IPTOS_DSCP_AF33: u32 = 120;
pub const IPTOS_DSCP_AF41: u32 = 136;
pub const IPTOS_DSCP_AF42: u32 = 144;
pub const IPTOS_DSCP_AF43: u32 = 152;
pub const IPTOS_DSCP_EF: u32 = 184;
pub const IPTOS_CLASS_MASK: u32 = 224;
pub const IPTOS_CLASS_CS0: u32 = 0;
pub const IPTOS_CLASS_CS1: u32 = 32;
pub const IPTOS_CLASS_CS2: u32 = 64;
pub const IPTOS_CLASS_CS3: u32 = 96;
pub const IPTOS_CLASS_CS4: u32 = 128;
pub const IPTOS_CLASS_CS5: u32 = 160;
pub const IPTOS_CLASS_CS6: u32 = 192;
pub const IPTOS_CLASS_CS7: u32 = 224;
pub const IPTOS_CLASS_DEFAULT: u32 = 0;
pub const IPTOS_TOS_MASK: u32 = 30;
pub const IPTOS_LOWDELAY: u32 = 16;
pub const IPTOS_THROUGHPUT: u32 = 8;
pub const IPTOS_RELIABILITY: u32 = 4;
pub const IPTOS_LOWCOST: u32 = 2;
pub const IPTOS_MINCOST: u32 = 2;
pub const IPTOS_PREC_MASK: u32 = 224;
pub const IPTOS_PREC_NETCONTROL: u32 = 224;
pub const IPTOS_PREC_INTERNETCONTROL: u32 = 192;
pub const IPTOS_PREC_CRITIC_ECP: u32 = 160;
pub const IPTOS_PREC_FLASHOVERRIDE: u32 = 128;
pub const IPTOS_PREC_FLASH: u32 = 96;
pub const IPTOS_PREC_IMMEDIATE: u32 = 64;
pub const IPTOS_PREC_PRIORITY: u32 = 32;
pub const IPTOS_PREC_ROUTINE: u32 = 0;
pub const IPOPT_COPY: u32 = 128;
pub const IPOPT_CLASS_MASK: u32 = 96;
pub const IPOPT_NUMBER_MASK: u32 = 31;
pub const IPOPT_CONTROL: u32 = 0;
pub const IPOPT_RESERVED1: u32 = 32;
pub const IPOPT_DEBMEAS: u32 = 64;
pub const IPOPT_MEASUREMENT: u32 = 64;
pub const IPOPT_RESERVED2: u32 = 96;
pub const IPOPT_EOL: u32 = 0;
pub const IPOPT_END: u32 = 0;
pub const IPOPT_NOP: u32 = 1;
pub const IPOPT_NOOP: u32 = 1;
pub const IPOPT_RR: u32 = 7;
pub const IPOPT_TS: u32 = 68;
pub const IPOPT_TIMESTAMP: u32 = 68;
pub const IPOPT_SECURITY: u32 = 130;
pub const IPOPT_SEC: u32 = 130;
pub const IPOPT_LSRR: u32 = 131;
pub const IPOPT_SATID: u32 = 136;
pub const IPOPT_SID: u32 = 136;
pub const IPOPT_SSRR: u32 = 137;
pub const IPOPT_RA: u32 = 148;
pub const IPOPT_OPTVAL: u32 = 0;
pub const IPOPT_OLEN: u32 = 1;
pub const IPOPT_OFFSET: u32 = 2;
pub const IPOPT_MINOFF: u32 = 4;
pub const MAX_IPOPTLEN: u32 = 40;
pub const IPOPT_TS_TSONLY: u32 = 0;
pub const IPOPT_TS_TSANDADDR: u32 = 1;
pub const IPOPT_TS_PRESPEC: u32 = 3;
pub const IPOPT_SECUR_UNCLASS: u32 = 0;
pub const IPOPT_SECUR_CONFID: u32 = 61749;
pub const IPOPT_SECUR_EFTO: u32 = 30874;
pub const IPOPT_SECUR_MMMM: u32 = 48205;
pub const IPOPT_SECUR_RESTR: u32 = 44819;
pub const IPOPT_SECUR_SECRET: u32 = 55176;
pub const IPOPT_SECUR_TOPSECRET: u32 = 27589;
pub const MAXTTL: u32 = 255;
pub const IPDEFTTL: u32 = 64;
pub const IPFRAGTTL: u32 = 60;
pub const IPTTLDEC: u32 = 1;
pub const IP_MSS: u32 = 576;
pub const __NETINET_UDP_H: u32 = 1;
pub const UDP_CORK: u32 = 1;
pub const UDP_ENCAP: u32 = 100;
pub const UDP_NO_CHECK6_TX: u32 = 101;
pub const UDP_NO_CHECK6_RX: u32 = 102;
pub const UDP_ENCAP_ESPINUDP_NON_IKE: u32 = 1;
pub const UDP_ENCAP_ESPINUDP: u32 = 2;
pub const UDP_ENCAP_L2TPINUDP: u32 = 3;
pub const UDP_ENCAP_GTP0: u32 = 4;
pub const UDP_ENCAP_GTP1U: u32 = 5;
pub const SOL_UDP: u32 = 17;
pub const _ASSERT_H: u32 = 1;
pub const ZFUT_FLAG_DONT_FRAGMENT: u32 = 16384;
pub const ZF_PKT_REPORT_CLOCK_SET: u32 = 1;
pub const ZF_PKT_REPORT_IN_SYNC: u32 = 2;
pub const ZF_PKT_REPORT_NO_TIMESTAMP: u32 = 4;
pub const ZF_PKT_REPORT_DROPPED: u32 = 8;
pub const ZF_PKT_REPORT_TCP_RETRANS: u32 = 8192;
pub const ZF_PKT_REPORT_TCP_SYN: u32 = 16384;
pub const ZF_PKT_REPORT_TCP_FIN: u32 = 32768;
pub const ZF_DELEGATED_SEND_RC_FATAL: u32 = 128;
pub const TCP_OFFSET_SEQ_TO_FLAGS: u32 = 9;
pub const TCP_FLAG_PSH: u32 = 8;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__fsid_t),
        "::",
        stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(imaxdiv_t),
        "::",
        stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(imaxdiv_t),
        "::",
        stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type size_t = ::std::os::raw::c_ulong;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(tm),
        "::",
        stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(tm),
        "::",
        stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(tm),
        "::",
        stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(tm),
        "::",
        stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(tm),
        "::",
        stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(tm),
        "::",
        stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(tm),
        "::",
        stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
        "Offset of field: ",
        stringify!(tm),
        "::",
        stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(tm),
        "::",
        stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(tm),
        "::",
        stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
        "Offset of field: ",
        stringify!(tm),
        "::",
        stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(timespec),
        "::",
        stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(timespec),
        "::",
        stringify!(tv_nsec)
        )
    );
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(itimerspec),
        "::",
        stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(itimerspec),
        "::",
        stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__locale_struct),
        "::",
        stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
        "Offset of field: ",
        stringify!(__locale_struct),
        "::",
        stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
        "Offset of field: ",
        stringify!(__locale_struct),
        "::",
        stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
        "Offset of field: ",
        stringify!(__locale_struct),
        "::",
        stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
        "Offset of field: ",
        stringify!(__locale_struct),
        "::",
        stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__sigset_t),
        "::",
        stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(timeval),
        "::",
        stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(timeval),
        "::",
        stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(fd_set),
        "::",
        stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_rwlock_arch_t),
        "::",
        stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_rwlock_arch_t),
        "::",
        stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_rwlock_arch_t),
        "::",
        stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_rwlock_arch_t),
        "::",
        stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_rwlock_arch_t),
        "::",
        stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_rwlock_arch_t),
        "::",
        stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_rwlock_arch_t),
        "::",
        stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_rwlock_arch_t),
        "::",
        stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_rwlock_arch_t),
        "::",
        stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_rwlock_arch_t),
        "::",
        stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_rwlock_arch_t),
        "::",
        stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_rwlock_arch_t),
        "::",
        stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_internal_list),
        "::",
        stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_internal_list),
        "::",
        stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_mutex_s),
        "::",
        stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_mutex_s),
        "::",
        stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_mutex_s),
        "::",
        stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_mutex_s),
        "::",
        stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_mutex_s),
        "::",
        stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_mutex_s),
        "::",
        stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_mutex_s),
        "::",
        stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_mutex_s),
        "::",
        stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
        "Size of: ",
        stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
        "Alignment of ",
        stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
        "::",
        stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
        "::",
        stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_cond_s__bindgen_ty_1),
        "::",
        stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_cond_s__bindgen_ty_1),
        "::",
        stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
        "Size of: ",
        stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
        "Alignment of ",
        stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
        "::",
        stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
        "::",
        stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_cond_s__bindgen_ty_2),
        "::",
        stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_cond_s__bindgen_ty_2),
        "::",
        stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_cond_s),
        "::",
        stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_cond_s),
        "::",
        stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_cond_s),
        "::",
        stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_cond_s),
        "::",
        stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(__pthread_cond_s),
        "::",
        stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_mutexattr_t),
        "::",
        stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_mutexattr_t),
        "::",
        stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_condattr_t),
        "::",
        stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_condattr_t),
        "::",
        stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_attr_t),
        "::",
        stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_attr_t),
        "::",
        stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_mutex_t),
        "::",
        stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_mutex_t),
        "::",
        stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_mutex_t),
        "::",
        stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_cond_t),
        "::",
        stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_cond_t),
        "::",
        stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_cond_t),
        "::",
        stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_rwlock_t),
        "::",
        stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_rwlock_t),
        "::",
        stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_rwlock_t),
        "::",
        stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_rwlockattr_t),
        "::",
        stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_rwlockattr_t),
        "::",
        stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_barrier_t),
        "::",
        stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_barrier_t),
        "::",
        stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_barrierattr_t),
        "::",
        stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(pthread_barrierattr_t),
        "::",
        stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(iovec),
        "::",
        stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(iovec),
        "::",
        stringify!(iov_len)
        )
    );
}
extern "C" {
    pub fn readv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn writev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn preadv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwritev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
pub type ef_eventq_ptr = u32;
pub type ef_addr = u64;
pub type ef_vi_ioaddr_t = *mut ::std::os::raw::c_char;
pub type ef_request_id = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ef_event {
    pub generic: ef_event__bindgen_ty_1,
    pub rx: ef_event__bindgen_ty_2,
    pub rx_discard: ef_event__bindgen_ty_3,
    pub tx: ef_event__bindgen_ty_4,
    pub tx_error: ef_event__bindgen_ty_5,
    pub tx_timestamp: ef_event__bindgen_ty_6,
    pub tx_alt: ef_event__bindgen_ty_7,
    pub rx_no_desc_trunc: ef_event__bindgen_ty_8,
    pub rx_packed_stream: ef_event__bindgen_ty_9,
    pub sw: ef_event__bindgen_ty_10,
    pub rx_multi: ef_event__bindgen_ty_11,
    pub rx_multi_discard: ef_event__bindgen_ty_12,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ef_event__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
#[test]
fn bindgen_test_layout_ef_event__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ef_event__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ef_event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_event__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_event__bindgen_ty_1))
    );
}
impl ef_event__bindgen_ty_1 {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(type_: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ef_event__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 12usize]>,
}
#[test]
fn bindgen_test_layout_ef_event__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ef_event__bindgen_ty_2>(),
        12usize,
        concat!("Size of: ", stringify!(ef_event__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_event__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_event__bindgen_ty_2))
    );
}
impl ef_event__bindgen_ty_2 {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn q_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_q_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rq_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_rq_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn len(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_len(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::std::os::raw::c_uint,
        q_id: ::std::os::raw::c_uint,
        __reserved: ::std::os::raw::c_uint,
        rq_id: ::std::os::raw::c_uint,
        len: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 12usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let q_id: u32 = unsafe { ::std::mem::transmute(q_id) };
            q_id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let __reserved: u32 = unsafe { ::std::mem::transmute(__reserved) };
            __reserved as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let rq_id: u32 = unsafe { ::std::mem::transmute(rq_id) };
            rq_id as u64
        });
        __bindgen_bitfield_unit.set(64usize, 16u8, {
            let len: u32 = unsafe { ::std::mem::transmute(len) };
            len as u64
        });
        __bindgen_bitfield_unit.set(80usize, 16u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ef_event__bindgen_ty_3 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 14usize]>,
}
#[test]
fn bindgen_test_layout_ef_event__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<ef_event__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(ef_event__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_event__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_event__bindgen_ty_3))
    );
}
impl ef_event__bindgen_ty_3 {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn q_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_q_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rq_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_rq_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn len(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_len(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn subtype(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_subtype(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::std::os::raw::c_uint,
        q_id: ::std::os::raw::c_uint,
        __reserved: ::std::os::raw::c_uint,
        rq_id: ::std::os::raw::c_uint,
        len: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
        subtype: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 14usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 14usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let q_id: u32 = unsafe { ::std::mem::transmute(q_id) };
            q_id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let __reserved: u32 = unsafe { ::std::mem::transmute(__reserved) };
            __reserved as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let rq_id: u32 = unsafe { ::std::mem::transmute(rq_id) };
            rq_id as u64
        });
        __bindgen_bitfield_unit.set(64usize, 16u8, {
            let len: u32 = unsafe { ::std::mem::transmute(len) };
            len as u64
        });
        __bindgen_bitfield_unit.set(80usize, 16u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(96usize, 16u8, {
            let subtype: u32 = unsafe { ::std::mem::transmute(subtype) };
            subtype as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ef_event__bindgen_ty_4 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub __bindgen_padding_0: u16,
}
#[test]
fn bindgen_test_layout_ef_event__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<ef_event__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(ef_event__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_event__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_event__bindgen_ty_4))
    );
}
impl ef_event__bindgen_ty_4 {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn q_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_q_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn desc_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_desc_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::std::os::raw::c_uint,
        q_id: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
        desc_id: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let q_id: u32 = unsafe { ::std::mem::transmute(q_id) };
            q_id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let desc_id: u32 = unsafe { ::std::mem::transmute(desc_id) };
            desc_id as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ef_event__bindgen_ty_5 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_ef_event__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<ef_event__bindgen_ty_5>(),
        8usize,
        concat!("Size of: ", stringify!(ef_event__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_event__bindgen_ty_5>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_event__bindgen_ty_5))
    );
}
impl ef_event__bindgen_ty_5 {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn q_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_q_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn desc_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_desc_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn subtype(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_subtype(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::std::os::raw::c_uint,
        q_id: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
        desc_id: ::std::os::raw::c_uint,
        subtype: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let q_id: u32 = unsafe { ::std::mem::transmute(q_id) };
            q_id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let desc_id: u32 = unsafe { ::std::mem::transmute(desc_id) };
            desc_id as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let subtype: u32 = unsafe { ::std::mem::transmute(subtype) };
            subtype as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ef_event__bindgen_ty_6 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
#[test]
fn bindgen_test_layout_ef_event__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<ef_event__bindgen_ty_6>(),
        16usize,
        concat!("Size of: ", stringify!(ef_event__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_event__bindgen_ty_6>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_event__bindgen_ty_6))
    );
}
impl ef_event__bindgen_ty_6 {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn q_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_q_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rq_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_rq_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn ts_sec(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_ts_sec(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn ts_nsec(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_ts_nsec(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::std::os::raw::c_uint,
        q_id: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
        rq_id: ::std::os::raw::c_uint,
        ts_sec: ::std::os::raw::c_uint,
        ts_nsec: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let q_id: u32 = unsafe { ::std::mem::transmute(q_id) };
            q_id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let rq_id: u32 = unsafe { ::std::mem::transmute(rq_id) };
            rq_id as u64
        });
        __bindgen_bitfield_unit.set(64usize, 32u8, {
            let ts_sec: u32 = unsafe { ::std::mem::transmute(ts_sec) };
            ts_sec as u64
        });
        __bindgen_bitfield_unit.set(96usize, 32u8, {
            let ts_nsec: u32 = unsafe { ::std::mem::transmute(ts_nsec) };
            ts_nsec as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ef_event__bindgen_ty_7 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub __bindgen_padding_0: u16,
}
#[test]
fn bindgen_test_layout_ef_event__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<ef_event__bindgen_ty_7>(),
        8usize,
        concat!("Size of: ", stringify!(ef_event__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_event__bindgen_ty_7>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_event__bindgen_ty_7))
    );
}
impl ef_event__bindgen_ty_7 {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn q_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_q_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn alt_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_alt_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::std::os::raw::c_uint,
        q_id: ::std::os::raw::c_uint,
        __reserved: ::std::os::raw::c_uint,
        alt_id: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let q_id: u32 = unsafe { ::std::mem::transmute(q_id) };
            q_id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let __reserved: u32 = unsafe { ::std::mem::transmute(__reserved) };
            __reserved as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let alt_id: u32 = unsafe { ::std::mem::transmute(alt_id) };
            alt_id as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ef_event__bindgen_ty_8 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
}
#[test]
fn bindgen_test_layout_ef_event__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<ef_event__bindgen_ty_8>(),
        4usize,
        concat!("Size of: ", stringify!(ef_event__bindgen_ty_8))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_event__bindgen_ty_8>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_event__bindgen_ty_8))
    );
}
impl ef_event__bindgen_ty_8 {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn q_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_q_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::std::os::raw::c_uint,
        q_id: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let q_id: u32 = unsafe { ::std::mem::transmute(q_id) };
            q_id as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ef_event__bindgen_ty_9 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 9usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_ef_event__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<ef_event__bindgen_ty_9>(),
        12usize,
        concat!("Size of: ", stringify!(ef_event__bindgen_ty_9))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_event__bindgen_ty_9>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_event__bindgen_ty_9))
    );
}
impl ef_event__bindgen_ty_9 {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn q_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_q_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn n_pkts(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_n_pkts(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn ps_flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ps_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::std::os::raw::c_uint,
        q_id: ::std::os::raw::c_uint,
        __reserved: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
        n_pkts: ::std::os::raw::c_uint,
        ps_flags: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 9usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 9usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let q_id: u32 = unsafe { ::std::mem::transmute(q_id) };
            q_id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let __reserved: u32 = unsafe { ::std::mem::transmute(__reserved) };
            __reserved as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let n_pkts: u32 = unsafe { ::std::mem::transmute(n_pkts) };
            n_pkts as u64
        });
        __bindgen_bitfield_unit.set(64usize, 8u8, {
            let ps_flags: u32 = unsafe { ::std::mem::transmute(ps_flags) };
            ps_flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_event__bindgen_ty_10 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub data: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ef_event__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<ef_event__bindgen_ty_10>(),
        8usize,
        concat!("Size of: ", stringify!(ef_event__bindgen_ty_10))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_event__bindgen_ty_10>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_event__bindgen_ty_10))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_event__bindgen_ty_10>())).data as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_event__bindgen_ty_10),
        "::",
        stringify!(data)
        )
    );
}
impl ef_event__bindgen_ty_10 {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(type_: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ef_event__bindgen_ty_11 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_ef_event__bindgen_ty_11() {
    assert_eq!(
        ::std::mem::size_of::<ef_event__bindgen_ty_11>(),
        8usize,
        concat!("Size of: ", stringify!(ef_event__bindgen_ty_11))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_event__bindgen_ty_11>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_event__bindgen_ty_11))
    );
}
impl ef_event__bindgen_ty_11 {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn q_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_q_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn n_descs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_n_descs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::std::os::raw::c_uint,
        q_id: ::std::os::raw::c_uint,
        __reserved: ::std::os::raw::c_uint,
        n_descs: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let q_id: u32 = unsafe { ::std::mem::transmute(q_id) };
            q_id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let __reserved: u32 = unsafe { ::std::mem::transmute(__reserved) };
            __reserved as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let n_descs: u32 = unsafe { ::std::mem::transmute(n_descs) };
            n_descs as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ef_event__bindgen_ty_12 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 10usize]>,
    pub __bindgen_padding_0: u16,
}
#[test]
fn bindgen_test_layout_ef_event__bindgen_ty_12() {
    assert_eq!(
        ::std::mem::size_of::<ef_event__bindgen_ty_12>(),
        12usize,
        concat!("Size of: ", stringify!(ef_event__bindgen_ty_12))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_event__bindgen_ty_12>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_event__bindgen_ty_12))
    );
}
impl ef_event__bindgen_ty_12 {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn q_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_q_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn n_descs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_n_descs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn subtype(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_subtype(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::std::os::raw::c_uint,
        q_id: ::std::os::raw::c_uint,
        __reserved: ::std::os::raw::c_uint,
        n_descs: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
        subtype: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 10usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 10usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let q_id: u32 = unsafe { ::std::mem::transmute(q_id) };
            q_id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let __reserved: u32 = unsafe { ::std::mem::transmute(__reserved) };
            __reserved as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let n_descs: u32 = unsafe { ::std::mem::transmute(n_descs) };
            n_descs as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(64usize, 16u8, {
            let subtype: u32 = unsafe { ::std::mem::transmute(subtype) };
            subtype as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ef_event() {
    assert_eq!(
        ::std::mem::size_of::<ef_event>(),
        16usize,
        concat!("Size of: ", stringify!(ef_event))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_event>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_event>())).generic as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_event),
        "::",
        stringify!(generic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_event>())).rx as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_event),
        "::",
        stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_event>())).rx_discard as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_event),
        "::",
        stringify!(rx_discard)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_event>())).tx as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_event),
        "::",
        stringify!(tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_event>())).tx_error as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_event),
        "::",
        stringify!(tx_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_event>())).tx_timestamp as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_event),
        "::",
        stringify!(tx_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_event>())).tx_alt as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_event),
        "::",
        stringify!(tx_alt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_event>())).rx_no_desc_trunc as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_event),
        "::",
        stringify!(rx_no_desc_trunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_event>())).rx_packed_stream as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_event),
        "::",
        stringify!(rx_packed_stream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_event>())).sw as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_event),
        "::",
        stringify!(sw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_event>())).rx_multi as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_event),
        "::",
        stringify!(rx_multi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_event>())).rx_multi_discard as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_event),
        "::",
        stringify!(rx_multi_discard)
        )
    );
}
pub const EF_EVENT_TYPE_RX: ::std::os::raw::c_uint = 0;
pub const EF_EVENT_TYPE_TX: ::std::os::raw::c_uint = 1;
pub const EF_EVENT_TYPE_RX_DISCARD: ::std::os::raw::c_uint = 2;
pub const EF_EVENT_TYPE_TX_ERROR: ::std::os::raw::c_uint = 3;
pub const EF_EVENT_TYPE_RX_NO_DESC_TRUNC: ::std::os::raw::c_uint = 4;
pub const EF_EVENT_TYPE_SW: ::std::os::raw::c_uint = 5;
pub const EF_EVENT_TYPE_OFLOW: ::std::os::raw::c_uint = 6;
pub const EF_EVENT_TYPE_TX_WITH_TIMESTAMP: ::std::os::raw::c_uint = 7;
pub const EF_EVENT_TYPE_RX_PACKED_STREAM: ::std::os::raw::c_uint = 8;
pub const EF_EVENT_TYPE_RX_MULTI: ::std::os::raw::c_uint = 9;
pub const EF_EVENT_TYPE_TX_ALT: ::std::os::raw::c_uint = 10;
pub const EF_EVENT_TYPE_RX_MULTI_DISCARD: ::std::os::raw::c_uint = 11;
pub const EF_EVENT_TYPE_RESET: ::std::os::raw::c_uint = 12;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const EF_EVENT_RX_DISCARD_CSUM_BAD: ::std::os::raw::c_uint = 0;
pub const EF_EVENT_RX_DISCARD_MCAST_MISMATCH: ::std::os::raw::c_uint = 1;
pub const EF_EVENT_RX_DISCARD_CRC_BAD: ::std::os::raw::c_uint = 2;
pub const EF_EVENT_RX_DISCARD_TRUNC: ::std::os::raw::c_uint = 3;
pub const EF_EVENT_RX_DISCARD_RIGHTS: ::std::os::raw::c_uint = 4;
pub const EF_EVENT_RX_DISCARD_EV_ERROR: ::std::os::raw::c_uint = 5;
pub const EF_EVENT_RX_DISCARD_OTHER: ::std::os::raw::c_uint = 6;
pub const EF_EVENT_RX_DISCARD_INNER_CSUM_BAD: ::std::os::raw::c_uint = 7;
pub const EF_EVENT_RX_DISCARD_MAX: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const EF_EVENT_TX_ERROR_RIGHTS: ::std::os::raw::c_uint = 0;
pub const EF_EVENT_TX_ERROR_OFLOW: ::std::os::raw::c_uint = 1;
pub const EF_EVENT_TX_ERROR_2BIG: ::std::os::raw::c_uint = 2;
pub const EF_EVENT_TX_ERROR_BUS: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_iovec {
    pub iov_base: ef_addr,
    pub iov_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ef_iovec() {
    assert_eq!(
        ::std::mem::size_of::<ef_iovec>(),
        16usize,
        concat!("Size of: ", stringify!(ef_iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(ef_iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_iovec),
        "::",
        stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_iovec),
        "::",
        stringify!(iov_len)
        )
    );
}
pub const ef_vi_flags_EF_VI_FLAGS_DEFAULT: ef_vi_flags = 0;
pub const ef_vi_flags_EF_VI_ISCSI_RX_HDIG: ef_vi_flags = 2;
pub const ef_vi_flags_EF_VI_ISCSI_TX_HDIG: ef_vi_flags = 4;
pub const ef_vi_flags_EF_VI_ISCSI_RX_DDIG: ef_vi_flags = 8;
pub const ef_vi_flags_EF_VI_ISCSI_TX_DDIG: ef_vi_flags = 16;
pub const ef_vi_flags_EF_VI_TX_PHYS_ADDR: ef_vi_flags = 32;
pub const ef_vi_flags_EF_VI_RX_PHYS_ADDR: ef_vi_flags = 64;
pub const ef_vi_flags_EF_VI_TX_IP_CSUM_DIS: ef_vi_flags = 128;
pub const ef_vi_flags_EF_VI_TX_TCPUDP_CSUM_DIS: ef_vi_flags = 256;
pub const ef_vi_flags_EF_VI_TX_TCPUDP_ONLY: ef_vi_flags = 512;
pub const ef_vi_flags_EF_VI_TX_FILTER_IP: ef_vi_flags = 1024;
pub const ef_vi_flags_EF_VI_TX_FILTER_MAC: ef_vi_flags = 2048;
pub const ef_vi_flags_EF_VI_TX_FILTER_MASK_1: ef_vi_flags = 4096;
pub const ef_vi_flags_EF_VI_TX_FILTER_MASK_2: ef_vi_flags = 8192;
pub const ef_vi_flags_EF_VI_TX_FILTER_MASK_3: ef_vi_flags = 12288;
pub const ef_vi_flags_EF_VI_TX_PUSH_DISABLE: ef_vi_flags = 16384;
pub const ef_vi_flags_EF_VI_TX_PUSH_ALWAYS: ef_vi_flags = 32768;
pub const ef_vi_flags_EF_VI_RX_TIMESTAMPS: ef_vi_flags = 65536;
pub const ef_vi_flags_EF_VI_TX_TIMESTAMPS: ef_vi_flags = 131072;
pub const ef_vi_flags_EF_VI_RX_PACKED_STREAM: ef_vi_flags = 524288;
pub const ef_vi_flags_EF_VI_RX_PS_BUF_SIZE_64K: ef_vi_flags = 1048576;
pub const ef_vi_flags_EF_VI_RX_EVENT_MERGE: ef_vi_flags = 2097152;
pub const ef_vi_flags_EF_VI_TX_ALT: ef_vi_flags = 4194304;
pub const ef_vi_flags_EF_VI_ENABLE_EV_TIMER: ef_vi_flags = 8388608;
pub const ef_vi_flags_EF_VI_TX_CTPIO: ef_vi_flags = 16777216;
pub const ef_vi_flags_EF_VI_TX_CTPIO_NO_POISON: ef_vi_flags = 33554432;
pub type ef_vi_flags = ::std::os::raw::c_uint;
pub const ef_vi_out_flags_EF_VI_OUT_CLOCK_SYNC_STATUS: ef_vi_out_flags = 1;
pub type ef_vi_out_flags = ::std::os::raw::c_uint;
pub const ef_vi_rx_discard_err_flags_EF_VI_DISCARD_RX_L4_CSUM_ERR: ef_vi_rx_discard_err_flags = 1;
pub const ef_vi_rx_discard_err_flags_EF_VI_DISCARD_RX_L3_CSUM_ERR: ef_vi_rx_discard_err_flags = 2;
pub const ef_vi_rx_discard_err_flags_EF_VI_DISCARD_RX_ETH_FCS_ERR: ef_vi_rx_discard_err_flags = 4;
pub const ef_vi_rx_discard_err_flags_EF_VI_DISCARD_RX_ETH_LEN_ERR: ef_vi_rx_discard_err_flags = 8;
pub const ef_vi_rx_discard_err_flags_EF_VI_DISCARD_RX_TOBE_DISC: ef_vi_rx_discard_err_flags = 16;
pub const ef_vi_rx_discard_err_flags_EF_VI_DISCARD_RX_INNER_L4_CSUM_ERR:
ef_vi_rx_discard_err_flags = 32;
pub const ef_vi_rx_discard_err_flags_EF_VI_DISCARD_RX_INNER_L3_CSUM_ERR:
ef_vi_rx_discard_err_flags = 64;
pub type ef_vi_rx_discard_err_flags = ::std::os::raw::c_uint;
pub const ef_timestamp_format_TS_FORMAT_SECONDS_27FRACTION: ef_timestamp_format = 0;
pub const ef_timestamp_format_TS_FORMAT_SECONDS_QTR_NANOSECONDS: ef_timestamp_format = 1;
pub type ef_timestamp_format = ::std::os::raw::c_uint;
pub const ef_vi_arch_EF_VI_ARCH_FALCON: ef_vi_arch = 0;
pub const ef_vi_arch_EF_VI_ARCH_EF10: ef_vi_arch = 1;
pub type ef_vi_arch = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_vi_txq_state {
    pub previous: u32,
    pub added: u32,
    pub removed: u32,
    pub ts_nsec: u32,
}
#[test]
fn bindgen_test_layout_ef_vi_txq_state() {
    assert_eq!(
        ::std::mem::size_of::<ef_vi_txq_state>(),
        16usize,
        concat!("Size of: ", stringify!(ef_vi_txq_state))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_vi_txq_state>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_vi_txq_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_txq_state>())).previous as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_txq_state),
        "::",
        stringify!(previous)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_txq_state>())).added as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_txq_state),
        "::",
        stringify!(added)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_txq_state>())).removed as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_txq_state),
        "::",
        stringify!(removed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_txq_state>())).ts_nsec as *const _ as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_txq_state),
        "::",
        stringify!(ts_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_vi_rxq_state {
    pub posted: u32,
    pub added: u32,
    pub removed: u32,
    pub in_jumbo: u32,
    pub bytes_acc: u32,
    pub last_desc_i: u16,
    pub rx_ps_credit_avail: u16,
}
#[test]
fn bindgen_test_layout_ef_vi_rxq_state() {
    assert_eq!(
        ::std::mem::size_of::<ef_vi_rxq_state>(),
        24usize,
        concat!("Size of: ", stringify!(ef_vi_rxq_state))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_vi_rxq_state>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_vi_rxq_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_rxq_state>())).posted as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_rxq_state),
        "::",
        stringify!(posted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_rxq_state>())).added as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_rxq_state),
        "::",
        stringify!(added)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_rxq_state>())).removed as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_rxq_state),
        "::",
        stringify!(removed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_rxq_state>())).in_jumbo as *const _ as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_rxq_state),
        "::",
        stringify!(in_jumbo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_rxq_state>())).bytes_acc as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_rxq_state),
        "::",
        stringify!(bytes_acc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_rxq_state>())).last_desc_i as *const _ as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_rxq_state),
        "::",
        stringify!(last_desc_i)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_vi_rxq_state>())).rx_ps_credit_avail as *const _ as usize
        },
        22usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_rxq_state),
        "::",
        stringify!(rx_ps_credit_avail)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_eventq_state {
    pub evq_ptr: ef_eventq_ptr,
    pub evq_clear_stride: i32,
    pub sync_timestamp_major: u32,
    pub sync_timestamp_minor: u32,
    pub sync_timestamp_minimum: u32,
    pub sync_timestamp_synchronised: u32,
    pub sync_flags: u32,
}
#[test]
fn bindgen_test_layout_ef_eventq_state() {
    assert_eq!(
        ::std::mem::size_of::<ef_eventq_state>(),
        28usize,
        concat!("Size of: ", stringify!(ef_eventq_state))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_eventq_state>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_eventq_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_eventq_state>())).evq_ptr as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_eventq_state),
        "::",
        stringify!(evq_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_eventq_state>())).evq_clear_stride as *const _ as usize
        },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_eventq_state),
        "::",
        stringify!(evq_clear_stride)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_eventq_state>())).sync_timestamp_major as *const _ as usize
        },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_eventq_state),
        "::",
        stringify!(sync_timestamp_major)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_eventq_state>())).sync_timestamp_minor as *const _ as usize
        },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_eventq_state),
        "::",
        stringify!(sync_timestamp_minor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_eventq_state>())).sync_timestamp_minimum as *const _ as usize
        },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_eventq_state),
        "::",
        stringify!(sync_timestamp_minimum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_eventq_state>())).sync_timestamp_synchronised as *const _
                as usize
        },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_eventq_state),
        "::",
        stringify!(sync_timestamp_synchronised)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_eventq_state>())).sync_flags as *const _ as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_eventq_state),
        "::",
        stringify!(sync_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_vi_txq {
    pub mask: u32,
    pub descriptors: *mut ::std::os::raw::c_void,
    pub ids: *mut u32,
}
#[test]
fn bindgen_test_layout_ef_vi_txq() {
    assert_eq!(
        ::std::mem::size_of::<ef_vi_txq>(),
        24usize,
        concat!("Size of: ", stringify!(ef_vi_txq))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_vi_txq>(),
        8usize,
        concat!("Alignment of ", stringify!(ef_vi_txq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_txq>())).mask as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_txq),
        "::",
        stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_txq>())).descriptors as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_txq),
        "::",
        stringify!(descriptors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_txq>())).ids as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_txq),
        "::",
        stringify!(ids)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_vi_rxq {
    pub mask: u32,
    pub descriptors: *mut ::std::os::raw::c_void,
    pub ids: *mut u32,
}
#[test]
fn bindgen_test_layout_ef_vi_rxq() {
    assert_eq!(
        ::std::mem::size_of::<ef_vi_rxq>(),
        24usize,
        concat!("Size of: ", stringify!(ef_vi_rxq))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_vi_rxq>(),
        8usize,
        concat!("Alignment of ", stringify!(ef_vi_rxq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_rxq>())).mask as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_rxq),
        "::",
        stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_rxq>())).descriptors as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_rxq),
        "::",
        stringify!(descriptors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_rxq>())).ids as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_rxq),
        "::",
        stringify!(ids)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_vi_state {
    pub evq: ef_eventq_state,
    pub txq: ef_vi_txq_state,
    pub rxq: ef_vi_rxq_state,
}
#[test]
fn bindgen_test_layout_ef_vi_state() {
    assert_eq!(
        ::std::mem::size_of::<ef_vi_state>(),
        68usize,
        concat!("Size of: ", stringify!(ef_vi_state))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_vi_state>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_vi_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_state>())).evq as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_state),
        "::",
        stringify!(evq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_state>())).txq as *const _ as usize },
        28usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_state),
        "::",
        stringify!(txq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_state>())).rxq as *const _ as usize },
        44usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_state),
        "::",
        stringify!(rxq)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_vi_stats {
    pub rx_ev_lost: u32,
    pub rx_ev_bad_desc_i: u32,
    pub rx_ev_bad_q_label: u32,
    pub evq_gap: u32,
}
#[test]
fn bindgen_test_layout_ef_vi_stats() {
    assert_eq!(
        ::std::mem::size_of::<ef_vi_stats>(),
        16usize,
        concat!("Size of: ", stringify!(ef_vi_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_vi_stats>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_vi_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_stats>())).rx_ev_lost as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_stats),
        "::",
        stringify!(rx_ev_lost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_stats>())).rx_ev_bad_desc_i as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_stats),
        "::",
        stringify!(rx_ev_bad_desc_i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_stats>())).rx_ev_bad_q_label as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_stats),
        "::",
        stringify!(rx_ev_bad_q_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_stats>())).evq_gap as *const _ as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_stats),
        "::",
        stringify!(evq_gap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_vi_nic_type {
    pub arch: ::std::os::raw::c_uchar,
    pub variant: ::std::os::raw::c_char,
    pub revision: ::std::os::raw::c_uchar,
    pub nic_flags: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_ef_vi_nic_type() {
    assert_eq!(
        ::std::mem::size_of::<ef_vi_nic_type>(),
        4usize,
        concat!("Size of: ", stringify!(ef_vi_nic_type))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_vi_nic_type>(),
        1usize,
        concat!("Alignment of ", stringify!(ef_vi_nic_type))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_nic_type>())).arch as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_nic_type),
        "::",
        stringify!(arch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_nic_type>())).variant as *const _ as usize },
        1usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_nic_type),
        "::",
        stringify!(variant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_nic_type>())).revision as *const _ as usize },
        2usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_nic_type),
        "::",
        stringify!(revision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_nic_type>())).nic_flags as *const _ as usize },
        3usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_nic_type),
        "::",
        stringify!(nic_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_vi_transmit_alt_overhead {
    pub pre_round: u32,
    pub mask: u32,
    pub post_round: u32,
}
#[test]
fn bindgen_test_layout_ef_vi_transmit_alt_overhead() {
    assert_eq!(
        ::std::mem::size_of::<ef_vi_transmit_alt_overhead>(),
        12usize,
        concat!("Size of: ", stringify!(ef_vi_transmit_alt_overhead))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_vi_transmit_alt_overhead>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_vi_transmit_alt_overhead))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_vi_transmit_alt_overhead>())).pre_round as *const _ as usize
        },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_transmit_alt_overhead),
        "::",
        stringify!(pre_round)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_vi_transmit_alt_overhead>())).mask as *const _ as usize
        },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_transmit_alt_overhead),
        "::",
        stringify!(mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_vi_transmit_alt_overhead>())).post_round as *const _ as usize
        },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_transmit_alt_overhead),
        "::",
        stringify!(post_round)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_vi {
    pub inited: ::std::os::raw::c_uint,
    pub vi_resource_id: ::std::os::raw::c_uint,
    pub vi_i: ::std::os::raw::c_uint,
    pub rx_buffer_len: ::std::os::raw::c_uint,
    pub rx_prefix_len: ::std::os::raw::c_uint,
    pub rx_discard_mask: u64,
    pub rx_ts_correction: ::std::os::raw::c_int,
    pub tx_ts_correction_ns: ::std::os::raw::c_int,
    pub ts_format: ef_timestamp_format,
    pub vi_mem_mmap_ptr: *mut ::std::os::raw::c_char,
    pub vi_mem_mmap_bytes: ::std::os::raw::c_int,
    pub vi_io_mmap_ptr: *mut ::std::os::raw::c_char,
    pub vi_io_mmap_bytes: ::std::os::raw::c_int,
    pub vi_ctpio_mmap_ptr: *mut ::std::os::raw::c_char,
    pub vi_ctpio_wb_ticks: u32,
    pub ep_state_bytes: ::std::os::raw::c_int,
    pub vi_clustered: ::std::os::raw::c_int,
    pub vi_is_packed_stream: ::std::os::raw::c_int,
    pub vi_is_normal: ::std::os::raw::c_int,
    pub vi_ps_buf_size: ::std::os::raw::c_uint,
    pub io: ef_vi_ioaddr_t,
    pub linked_pio: *mut ef_pio,
    pub evq_base: *mut ::std::os::raw::c_char,
    pub evq_mask: ::std::os::raw::c_uint,
    pub timer_quantum_ns: ::std::os::raw::c_uint,
    pub tx_push_thresh: ::std::os::raw::c_uint,
    pub vi_txq: ef_vi_txq,
    pub vi_rxq: ef_vi_rxq,
    pub ep_state: *mut ef_vi_state,
    pub vi_flags: ef_vi_flags,
    pub vi_out_flags: ef_vi_out_flags,
    pub vi_stats: *mut ef_vi_stats,
    pub vi_qs: [*mut ef_vi; 32usize],
    pub vi_qs_n: ::std::os::raw::c_int,
    pub tx_alt_num: ::std::os::raw::c_uint,
    pub tx_alt_id2hw: *mut ::std::os::raw::c_uint,
    pub tx_alt_hw2id: *mut ::std::os::raw::c_uint,
    pub nic_type: ef_vi_nic_type,
    pub ops: ef_vi_ops,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_vi_ops {
    pub transmit: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ef_vi,
            base: ef_addr,
            len: ::std::os::raw::c_int,
            arg2: ef_request_id,
        ) -> ::std::os::raw::c_int,
    >,
    pub transmitv: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ef_vi,
            arg2: *const ef_iovec,
            iov_len: ::std::os::raw::c_int,
            arg3: ef_request_id,
        ) -> ::std::os::raw::c_int,
    >,
    pub transmitv_init: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ef_vi,
            arg2: *const ef_iovec,
            iov_len: ::std::os::raw::c_int,
            arg3: ef_request_id,
        ) -> ::std::os::raw::c_int,
    >,
    pub transmit_push: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ef_vi)>,
    pub transmit_pio: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ef_vi,
            offset: ::std::os::raw::c_int,
            len: ::std::os::raw::c_int,
            dma_id: ef_request_id,
        ) -> ::std::os::raw::c_int,
    >,
    pub transmit_copy_pio: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ef_vi,
            pio_offset: ::std::os::raw::c_int,
            src_buf: *const ::std::os::raw::c_void,
            len: ::std::os::raw::c_int,
            dma_id: ef_request_id,
        ) -> ::std::os::raw::c_int,
    >,
    pub transmit_pio_warm: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ef_vi)>,
    pub transmit_copy_pio_warm: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ef_vi,
            pio_offset: ::std::os::raw::c_int,
            src_buf: *const ::std::os::raw::c_void,
            len: ::std::os::raw::c_int,
        ),
    >,
    pub transmitv_ctpio: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ef_vi,
            frame_len: size_t,
            iov: *const iovec,
            iov_len: ::std::os::raw::c_int,
            threshold: ::std::os::raw::c_uint,
        ),
    >,
    pub transmitv_ctpio_copy: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ef_vi,
            frame_len: size_t,
            iov: *const iovec,
            iov_len: ::std::os::raw::c_int,
            threshold: ::std::os::raw::c_uint,
            fallback: *mut ::std::os::raw::c_void,
        ),
    >,
    pub transmit_alt_select: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ef_vi,
            alt_id: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub transmit_alt_select_default:
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ef_vi) -> ::std::os::raw::c_int>,
    pub transmit_alt_stop: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ef_vi,
            alt_id: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub transmit_alt_go: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ef_vi,
            alt_id: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub transmit_alt_discard: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ef_vi,
            alt_id: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub receive_init: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ef_vi,
            arg2: ef_addr,
            arg3: ef_request_id,
        ) -> ::std::os::raw::c_int,
    >,
    pub receive_push: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ef_vi)>,
    pub eventq_poll: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ef_vi,
            arg2: *mut ef_event,
            evs_len: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub eventq_prime: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ef_vi)>,
    pub eventq_timer_prime:
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ef_vi, v: ::std::os::raw::c_uint)>,
    pub eventq_timer_run:
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ef_vi, v: ::std::os::raw::c_uint)>,
    pub eventq_timer_clear: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ef_vi)>,
    pub eventq_timer_zero: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ef_vi)>,
}
#[test]
fn bindgen_test_layout_ef_vi_ops() {
    assert_eq!(
        ::std::mem::size_of::<ef_vi_ops>(),
        184usize,
        concat!("Size of: ", stringify!(ef_vi_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_vi_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(ef_vi_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).transmit as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(transmit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).transmitv as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(transmitv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).transmitv_init as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(transmitv_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).transmit_push as *const _ as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(transmit_push)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).transmit_pio as *const _ as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(transmit_pio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).transmit_copy_pio as *const _ as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(transmit_copy_pio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).transmit_pio_warm as *const _ as usize },
        48usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(transmit_pio_warm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_vi_ops>())).transmit_copy_pio_warm as *const _ as usize
        },
        56usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(transmit_copy_pio_warm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).transmitv_ctpio as *const _ as usize },
        64usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(transmitv_ctpio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).transmitv_ctpio_copy as *const _ as usize },
        72usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(transmitv_ctpio_copy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).transmit_alt_select as *const _ as usize },
        80usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(transmit_alt_select)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_vi_ops>())).transmit_alt_select_default as *const _ as usize
        },
        88usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(transmit_alt_select_default)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).transmit_alt_stop as *const _ as usize },
        96usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(transmit_alt_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).transmit_alt_go as *const _ as usize },
        104usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(transmit_alt_go)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).transmit_alt_discard as *const _ as usize },
        112usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(transmit_alt_discard)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).receive_init as *const _ as usize },
        120usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(receive_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).receive_push as *const _ as usize },
        128usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(receive_push)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).eventq_poll as *const _ as usize },
        136usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(eventq_poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).eventq_prime as *const _ as usize },
        144usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(eventq_prime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).eventq_timer_prime as *const _ as usize },
        152usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(eventq_timer_prime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).eventq_timer_run as *const _ as usize },
        160usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(eventq_timer_run)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).eventq_timer_clear as *const _ as usize },
        168usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(eventq_timer_clear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_ops>())).eventq_timer_zero as *const _ as usize },
        176usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_ops),
        "::",
        stringify!(eventq_timer_zero)
        )
    );
}
#[test]
fn bindgen_test_layout_ef_vi() {
    assert_eq!(
        ::std::mem::size_of::<ef_vi>(),
        696usize,
        concat!("Size of: ", stringify!(ef_vi))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_vi>(),
        8usize,
        concat!("Alignment of ", stringify!(ef_vi))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).inited as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(inited)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_resource_id as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_resource_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_i as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).rx_buffer_len as *const _ as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(rx_buffer_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).rx_prefix_len as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(rx_prefix_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).rx_discard_mask as *const _ as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(rx_discard_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).rx_ts_correction as *const _ as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(rx_ts_correction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).tx_ts_correction_ns as *const _ as usize },
        36usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(tx_ts_correction_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).ts_format as *const _ as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(ts_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_mem_mmap_ptr as *const _ as usize },
        48usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_mem_mmap_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_mem_mmap_bytes as *const _ as usize },
        56usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_mem_mmap_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_io_mmap_ptr as *const _ as usize },
        64usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_io_mmap_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_io_mmap_bytes as *const _ as usize },
        72usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_io_mmap_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_ctpio_mmap_ptr as *const _ as usize },
        80usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_ctpio_mmap_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_ctpio_wb_ticks as *const _ as usize },
        88usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_ctpio_wb_ticks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).ep_state_bytes as *const _ as usize },
        92usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(ep_state_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_clustered as *const _ as usize },
        96usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_clustered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_is_packed_stream as *const _ as usize },
        100usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_is_packed_stream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_is_normal as *const _ as usize },
        104usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_is_normal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_ps_buf_size as *const _ as usize },
        108usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_ps_buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).io as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(ef_vi), "::", stringify!(io))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).linked_pio as *const _ as usize },
        120usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(linked_pio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).evq_base as *const _ as usize },
        128usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(evq_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).evq_mask as *const _ as usize },
        136usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(evq_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).timer_quantum_ns as *const _ as usize },
        140usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(timer_quantum_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).tx_push_thresh as *const _ as usize },
        144usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(tx_push_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_txq as *const _ as usize },
        152usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_txq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_rxq as *const _ as usize },
        176usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_rxq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).ep_state as *const _ as usize },
        200usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(ep_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_flags as *const _ as usize },
        208usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_out_flags as *const _ as usize },
        212usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_out_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_stats as *const _ as usize },
        216usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_qs as *const _ as usize },
        224usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_qs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).vi_qs_n as *const _ as usize },
        480usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(vi_qs_n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).tx_alt_num as *const _ as usize },
        484usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(tx_alt_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).tx_alt_id2hw as *const _ as usize },
        488usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(tx_alt_id2hw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).tx_alt_hw2id as *const _ as usize },
        496usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(tx_alt_hw2id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).nic_type as *const _ as usize },
        504usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(nic_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi>())).ops as *const _ as usize },
        512usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi),
        "::",
        stringify!(ops)
        )
    );
}
extern "C" {
    pub fn ef_vi_version_str() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ef_vi_driver_interface_str() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ef_vi_receive_post(
        vi: *mut ef_vi,
        addr: ef_addr,
        dma_id: ef_request_id,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_receive_get_timestamp(
        vi: *mut ef_vi,
        pkt: *const ::std::os::raw::c_void,
        ts_out: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_receive_get_timestamp_with_sync_flags(
        vi: *mut ef_vi,
        pkt: *const ::std::os::raw::c_void,
        ts_out: *mut timespec,
        flags_out: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_receive_get_bytes(
        vi: *mut ef_vi,
        pkt: *const ::std::os::raw::c_void,
        bytes_out: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_receive_unbundle(
        ep: *mut ef_vi,
        event: *const ef_event,
        ids: *mut ef_request_id,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_receive_set_discards(
        vi: *mut ef_vi,
        discard_err_flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_transmit_init(
        vi: *mut ef_vi,
        addr: ef_addr,
        bytes: ::std::os::raw::c_int,
        dma_id: ef_request_id,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_transmit_init_undo(vi: *mut ef_vi);
}
extern "C" {
    pub fn ef_vi_transmit_unbundle(
        ep: *mut ef_vi,
        event: *const ef_event,
        ids: *mut ef_request_id,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_transmit_alt_num_ids(vi: *mut ef_vi) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ef_vi_transmit_alt_query_overhead(
        vi: *mut ef_vi,
        params: *mut ef_vi_transmit_alt_overhead,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_set_tx_push_threshold(vi: *mut ef_vi, threshold: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn ef_vi_transmit_ctpio_fallback(
        vi: *mut ef_vi,
        dma_addr: ef_addr,
        len: size_t,
        dma_id: ef_request_id,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_transmitv_ctpio_fallback(
        vi: *mut ef_vi,
        dma_iov: *const ef_iovec,
        dma_iov_len: ::std::os::raw::c_int,
        dma_id: ef_request_id,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_eventq_has_event(vi: *const ef_vi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_eventq_has_many_events(
        evq: *const ef_vi,
        n_events: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_eventq_capacity(vi: *mut ef_vi) -> ::std::os::raw::c_int;
}
pub const ef_vi_layout_type_EF_VI_LAYOUT_FRAME: ef_vi_layout_type = 0;
pub const ef_vi_layout_type_EF_VI_LAYOUT_MINOR_TICKS: ef_vi_layout_type = 1;
pub const ef_vi_layout_type_EF_VI_LAYOUT_PACKET_LENGTH: ef_vi_layout_type = 2;
pub type ef_vi_layout_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_vi_layout_entry {
    pub evle_type: ef_vi_layout_type,
    pub evle_offset: ::std::os::raw::c_int,
    pub evle_description: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ef_vi_layout_entry() {
    assert_eq!(
        ::std::mem::size_of::<ef_vi_layout_entry>(),
        16usize,
        concat!("Size of: ", stringify!(ef_vi_layout_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_vi_layout_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(ef_vi_layout_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_layout_entry>())).evle_type as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_layout_entry),
        "::",
        stringify!(evle_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_layout_entry>())).evle_offset as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_layout_entry),
        "::",
        stringify!(evle_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_vi_layout_entry>())).evle_description as *const _ as usize
        },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_layout_entry),
        "::",
        stringify!(evle_description)
        )
    );
}
extern "C" {
    pub fn ef_vi_receive_query_layout(
        vi: *mut ef_vi,
        layout_out: *mut *const ef_vi_layout_entry,
        layout_len_out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type ef_driver_handle = ::std::os::raw::c_int;
extern "C" {
    pub fn ef_eventq_wait(
        vi: *mut ef_vi,
        vi_dh: ef_driver_handle,
        current_ptr: ::std::os::raw::c_uint,
        timeout: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_driver_open(dh_out: *mut ef_driver_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_driver_close(dh: ef_driver_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_alloc_from_pd(
        vi: *mut ef_vi,
        vi_dh: ef_driver_handle,
        pd: *mut ef_pd,
        pd_dh: ef_driver_handle,
        evq_capacity: ::std::os::raw::c_int,
        rxq_capacity: ::std::os::raw::c_int,
        txq_capacity: ::std::os::raw::c_int,
        evq_opt: *mut ef_vi,
        evq_dh: ef_driver_handle,
        flags: ef_vi_flags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_free(vi: *mut ef_vi, nic: ef_driver_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_transmit_alt_alloc(
        vi: *mut ef_vi,
        vi_dh: ef_driver_handle,
        num_alts: ::std::os::raw::c_int,
        buf_space: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_transmit_alt_free(
        vi: *mut ef_vi,
        vi_dh: ef_driver_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_transmit_alt_query_buffering(
        vi: *mut ef_vi,
        ifindex: ::std::os::raw::c_int,
        vi_dh: ef_driver_handle,
        n_alts: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_flush(vi: *mut ef_vi, nic: ef_driver_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_pace(
        vi: *mut ef_vi,
        nic: ef_driver_handle,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_mtu(vi: *mut ef_vi, vi_dh: ef_driver_handle) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ef_vi_get_mac(
        vi: *mut ef_vi,
        vi_dh: ef_driver_handle,
        mac_out: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_eventq_put(
        resource_id: ::std::os::raw::c_uint,
        evq_dh: ef_driver_handle,
        ev_bits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_vi_set {
    pub vis_res_id: ::std::os::raw::c_uint,
    pub vis_pd: *mut ef_pd,
}
#[test]
fn bindgen_test_layout_ef_vi_set() {
    assert_eq!(
        ::std::mem::size_of::<ef_vi_set>(),
        16usize,
        concat!("Size of: ", stringify!(ef_vi_set))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_vi_set>(),
        8usize,
        concat!("Alignment of ", stringify!(ef_vi_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_set>())).vis_res_id as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_set),
        "::",
        stringify!(vis_res_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_set>())).vis_pd as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_set),
        "::",
        stringify!(vis_pd)
        )
    );
}
extern "C" {
    pub fn ef_vi_set_alloc_from_pd(
        vi_set: *mut ef_vi_set,
        vi_set_dh: ef_driver_handle,
        pd: *mut ef_pd,
        pd_dh: ef_driver_handle,
        n_vis: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_set_free(
        vi_set: *mut ef_vi_set,
        vi_set_dh: ef_driver_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_alloc_from_set(
        vi: *mut ef_vi,
        vi_dh: ef_driver_handle,
        vi_set: *mut ef_vi_set,
        vi_set_dh: ef_driver_handle,
        index_in_vi_set: ::std::os::raw::c_int,
        evq_capacity: ::std::os::raw::c_int,
        rxq_capacity: ::std::os::raw::c_int,
        txq_capacity: ::std::os::raw::c_int,
        evq_opt: *mut ef_vi,
        evq_dh: ef_driver_handle,
        flags: ef_vi_flags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_prime(
        vi: *mut ef_vi,
        dh: ef_driver_handle,
        current_ptr: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub const ef_filter_flags_EF_FILTER_FLAG_NONE: ef_filter_flags = 0;
pub const ef_filter_flags_EF_FILTER_FLAG_MCAST_LOOP_RECEIVE: ef_filter_flags = 2;
pub type ef_filter_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_filter_spec {
    pub type_: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
    pub data: [::std::os::raw::c_uint; 12usize],
}
#[test]
fn bindgen_test_layout_ef_filter_spec() {
    assert_eq!(
        ::std::mem::size_of::<ef_filter_spec>(),
        56usize,
        concat!("Size of: ", stringify!(ef_filter_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_filter_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_filter_spec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_filter_spec>())).type_ as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_filter_spec),
        "::",
        stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_filter_spec>())).flags as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_filter_spec),
        "::",
        stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_filter_spec>())).data as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_filter_spec),
        "::",
        stringify!(data)
        )
    );
}
pub const EF_FILTER_VLAN_ID_ANY: ::std::os::raw::c_int = -1;
pub type _bindgen_ty_4 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_filter_cookie {
    pub filter_id: ::std::os::raw::c_int,
    pub filter_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ef_filter_cookie() {
    assert_eq!(
        ::std::mem::size_of::<ef_filter_cookie>(),
        8usize,
        concat!("Size of: ", stringify!(ef_filter_cookie))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_filter_cookie>(),
        4usize,
        concat!("Alignment of ", stringify!(ef_filter_cookie))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_filter_cookie>())).filter_id as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_filter_cookie),
        "::",
        stringify!(filter_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_filter_cookie>())).filter_type as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_filter_cookie),
        "::",
        stringify!(filter_type)
        )
    );
}
extern "C" {
    pub fn ef_filter_spec_init(filter_spec: *mut ef_filter_spec, flags: ef_filter_flags);
}
extern "C" {
    pub fn ef_filter_spec_set_ip4_local(
        filter_spec: *mut ef_filter_spec,
        protocol: ::std::os::raw::c_int,
        host_be32: ::std::os::raw::c_uint,
        port_be16: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_filter_spec_set_ip4_full(
        filter_spec: *mut ef_filter_spec,
        protocol: ::std::os::raw::c_int,
        host_be32: ::std::os::raw::c_uint,
        port_be16: ::std::os::raw::c_int,
        rhost_be32: ::std::os::raw::c_uint,
        rport_be16: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_filter_spec_set_ip6_local(
        filter_spec: *mut ef_filter_spec,
        protocol: ::std::os::raw::c_int,
        host: *const in6_addr,
        port_be16: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_filter_spec_set_ip6_full(
        filter_spec: *mut ef_filter_spec,
        protocol: ::std::os::raw::c_int,
        host: *const in6_addr,
        port_be16: ::std::os::raw::c_int,
        rhost: *const in6_addr,
        rport_be16: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_filter_spec_set_vlan(
        filter_spec: *mut ef_filter_spec,
        vlan_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_filter_spec_set_eth_local(
        filter_spec: *mut ef_filter_spec,
        vlan_id: ::std::os::raw::c_int,
        mac: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_filter_spec_set_unicast_all(
        filter_spec: *mut ef_filter_spec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_filter_spec_set_multicast_all(
        filter_spec: *mut ef_filter_spec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_filter_spec_set_unicast_mismatch(
        filter_spec: *mut ef_filter_spec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_filter_spec_set_multicast_mismatch(
        filter_spec: *mut ef_filter_spec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_filter_spec_set_port_sniff(
        filter_spec: *mut ef_filter_spec,
        promiscuous: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_filter_spec_set_tx_port_sniff(
        filter_spec: *mut ef_filter_spec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_filter_spec_set_block_kernel(
        filter_spec: *mut ef_filter_spec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_filter_spec_set_block_kernel_multicast(
        filter_spec: *mut ef_filter_spec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_filter_spec_set_eth_type(
        filter_spec: *mut ef_filter_spec,
        ether_type_be16: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_filter_spec_set_ip_proto(
        filter_spec: *mut ef_filter_spec,
        ip_proto: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_filter_spec_set_block_kernel_unicast(
        filter_spec: *mut ef_filter_spec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_filter_add(
        vi: *mut ef_vi,
        vi_dh: ef_driver_handle,
        filter_spec: *const ef_filter_spec,
        filter_cookie_out: *mut ef_filter_cookie,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_filter_del(
        vi: *mut ef_vi,
        vi_dh: ef_driver_handle,
        filter_cookie: *mut ef_filter_cookie,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_set_filter_add(
        vi_set: *mut ef_vi_set,
        vi_set_dh: ef_driver_handle,
        filter_spec: *const ef_filter_spec,
        filter_cookie_out: *mut ef_filter_cookie,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_set_filter_del(
        vi_set: *mut ef_vi_set,
        vi_set_dh: ef_driver_handle,
        filter_cookie: *mut ef_filter_cookie,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_vi_stats_field_layout {
    pub evsfl_name: *mut ::std::os::raw::c_char,
    pub evsfl_offset: ::std::os::raw::c_int,
    pub evsfl_size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ef_vi_stats_field_layout() {
    assert_eq!(
        ::std::mem::size_of::<ef_vi_stats_field_layout>(),
        16usize,
        concat!("Size of: ", stringify!(ef_vi_stats_field_layout))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_vi_stats_field_layout>(),
        8usize,
        concat!("Alignment of ", stringify!(ef_vi_stats_field_layout))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_vi_stats_field_layout>())).evsfl_name as *const _ as usize
        },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_stats_field_layout),
        "::",
        stringify!(evsfl_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_vi_stats_field_layout>())).evsfl_offset as *const _ as usize
        },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_stats_field_layout),
        "::",
        stringify!(evsfl_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_vi_stats_field_layout>())).evsfl_size as *const _ as usize
        },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_stats_field_layout),
        "::",
        stringify!(evsfl_size)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct ef_vi_stats_layout {
    pub evsl_data_size: ::std::os::raw::c_int,
    pub evsl_fields_num: ::std::os::raw::c_int,
    pub evsl_fields: __IncompleteArrayField<ef_vi_stats_field_layout>,
}
#[test]
fn bindgen_test_layout_ef_vi_stats_layout() {
    assert_eq!(
        ::std::mem::size_of::<ef_vi_stats_layout>(),
        8usize,
        concat!("Size of: ", stringify!(ef_vi_stats_layout))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_vi_stats_layout>(),
        8usize,
        concat!("Alignment of ", stringify!(ef_vi_stats_layout))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_vi_stats_layout>())).evsl_data_size as *const _ as usize
        },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_stats_layout),
        "::",
        stringify!(evsl_data_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_vi_stats_layout>())).evsl_fields_num as *const _ as usize
        },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_stats_layout),
        "::",
        stringify!(evsl_fields_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_vi_stats_layout>())).evsl_fields as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_vi_stats_layout),
        "::",
        stringify!(evsl_fields)
        )
    );
}
extern "C" {
    pub fn ef_vi_stats_query_layout(
        vi: *mut ef_vi,
        layout_out: *mut *const ef_vi_stats_layout,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_stats_query(
        vi: *mut ef_vi,
        vi_dh: ef_driver_handle,
        data: *mut ::std::os::raw::c_void,
        do_reset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const ef_pd_flags_EF_PD_DEFAULT: ef_pd_flags = 0;
pub const ef_pd_flags_EF_PD_VF: ef_pd_flags = 1;
pub const ef_pd_flags_EF_PD_PHYS_MODE: ef_pd_flags = 2;
pub const ef_pd_flags_EF_PD_RX_PACKED_STREAM: ef_pd_flags = 4;
pub const ef_pd_flags_EF_PD_VPORT: ef_pd_flags = 8;
pub const ef_pd_flags_EF_PD_MCAST_LOOP: ef_pd_flags = 16;
pub const ef_pd_flags_EF_PD_MEMREG_64KiB: ef_pd_flags = 32;
pub const ef_pd_flags_EF_PD_IGNORE_BLACKLIST: ef_pd_flags = 64;
pub type ef_pd_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_pd {
    pub pd_flags: ef_pd_flags,
    pub pd_resource_id: ::std::os::raw::c_uint,
    pub pd_intf_name: *mut ::std::os::raw::c_char,
    pub pd_cluster_name: *mut ::std::os::raw::c_char,
    pub pd_cluster_sock: ::std::os::raw::c_int,
    pub pd_cluster_dh: ef_driver_handle,
    pub pd_cluster_viset_resource_id: ::std::os::raw::c_uint,
    pub pd_cluster_viset_index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ef_pd() {
    assert_eq!(
        ::std::mem::size_of::<ef_pd>(),
        40usize,
        concat!("Size of: ", stringify!(ef_pd))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_pd>(),
        8usize,
        concat!("Alignment of ", stringify!(ef_pd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_pd>())).pd_flags as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_pd),
        "::",
        stringify!(pd_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_pd>())).pd_resource_id as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_pd),
        "::",
        stringify!(pd_resource_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_pd>())).pd_intf_name as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_pd),
        "::",
        stringify!(pd_intf_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_pd>())).pd_cluster_name as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_pd),
        "::",
        stringify!(pd_cluster_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_pd>())).pd_cluster_sock as *const _ as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_pd),
        "::",
        stringify!(pd_cluster_sock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_pd>())).pd_cluster_dh as *const _ as usize },
        28usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_pd),
        "::",
        stringify!(pd_cluster_dh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ef_pd>())).pd_cluster_viset_resource_id as *const _ as usize
        },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_pd),
        "::",
        stringify!(pd_cluster_viset_resource_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_pd>())).pd_cluster_viset_index as *const _ as usize },
        36usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_pd),
        "::",
        stringify!(pd_cluster_viset_index)
        )
    );
}
extern "C" {
    pub fn ef_pd_alloc(
        pd: *mut ef_pd,
        pd_dh: ef_driver_handle,
        ifindex: ::std::os::raw::c_int,
        flags: ef_pd_flags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_pd_alloc_by_name(
        pd: *mut ef_pd,
        pd_dh: ef_driver_handle,
        cluster_or_intf_name: *const ::std::os::raw::c_char,
        flags: ef_pd_flags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_pd_alloc_with_vport(
        pd: *mut ef_pd,
        pd_dh: ef_driver_handle,
        intf_name: *const ::std::os::raw::c_char,
        flags: ef_pd_flags,
        vlan_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_pd_interface_name(pd: *mut ef_pd) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ef_pd_free(pd: *mut ef_pd, pd_dh: ef_driver_handle) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_pio {
    pub pio_buffer: *mut u8,
    pub pio_io: *mut u8,
    pub pio_resource_id: ::std::os::raw::c_uint,
    pub pio_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ef_pio() {
    assert_eq!(
        ::std::mem::size_of::<ef_pio>(),
        24usize,
        concat!("Size of: ", stringify!(ef_pio))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_pio>(),
        8usize,
        concat!("Alignment of ", stringify!(ef_pio))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_pio>())).pio_buffer as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_pio),
        "::",
        stringify!(pio_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_pio>())).pio_io as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_pio),
        "::",
        stringify!(pio_io)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_pio>())).pio_resource_id as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_pio),
        "::",
        stringify!(pio_resource_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_pio>())).pio_len as *const _ as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_pio),
        "::",
        stringify!(pio_len)
        )
    );
}
extern "C" {
    pub fn ef_pio_alloc(
        pio: *mut ef_pio,
        pio_dh: ef_driver_handle,
        pd: *mut ef_pd,
        len_hint: ::std::os::raw::c_uint,
        pd_dh: ef_driver_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_vi_get_pio_size(vi: *mut ef_vi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_pio_free(pio: *mut ef_pio, pio_dh: ef_driver_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_pio_link_vi(
        pio: *mut ef_pio,
        pio_dh: ef_driver_handle,
        vi: *mut ef_vi,
        vi_dh: ef_driver_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_pio_unlink_vi(
        pio: *mut ef_pio,
        pio_dh: ef_driver_handle,
        vi: *mut ef_vi,
        vi_dh: ef_driver_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_pio_memcpy(
        vi: *mut ef_vi,
        base: *const ::std::os::raw::c_void,
        offset: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ef_memreg {
    pub mr_dma_addrs: *mut ef_addr,
    pub mr_dma_addrs_base: *mut ef_addr,
}
#[test]
fn bindgen_test_layout_ef_memreg() {
    assert_eq!(
        ::std::mem::size_of::<ef_memreg>(),
        16usize,
        concat!("Size of: ", stringify!(ef_memreg))
    );
    assert_eq!(
        ::std::mem::align_of::<ef_memreg>(),
        8usize,
        concat!("Alignment of ", stringify!(ef_memreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_memreg>())).mr_dma_addrs as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_memreg),
        "::",
        stringify!(mr_dma_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ef_memreg>())).mr_dma_addrs_base as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ef_memreg),
        "::",
        stringify!(mr_dma_addrs_base)
        )
    );
}
extern "C" {
    pub fn ef_memreg_alloc(
        mr: *mut ef_memreg,
        mr_dh: ef_driver_handle,
        pd: *mut ef_pd,
        pd_dh: ef_driver_handle,
        p_mem: *mut ::std::os::raw::c_void,
        len_bytes: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ef_memreg_free(mr: *mut ef_memreg, mr_dh: ef_driver_handle) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zf_stack {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zf_attr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn zf_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_deinit() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_stack_alloc(
        attr: *mut zf_attr,
        stack_out: *mut *mut zf_stack,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_stack_free(stack: *mut zf_stack) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zf_waitable {
    _unused: [u8; 0],
}
extern "C" {
    pub fn zf_stack_to_waitable(arg1: *mut zf_stack) -> *mut zf_waitable;
}
extern "C" {
    pub fn zf_stack_is_quiescent(arg1: *mut zf_stack) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn zf_print_version();
}
pub const EPOLL_CLOEXEC: ::std::os::raw::c_uint = 524288;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const EPOLL_EVENTS_EPOLLIN: EPOLL_EVENTS = 1;
pub const EPOLL_EVENTS_EPOLLPRI: EPOLL_EVENTS = 2;
pub const EPOLL_EVENTS_EPOLLOUT: EPOLL_EVENTS = 4;
pub const EPOLL_EVENTS_EPOLLRDNORM: EPOLL_EVENTS = 64;
pub const EPOLL_EVENTS_EPOLLRDBAND: EPOLL_EVENTS = 128;
pub const EPOLL_EVENTS_EPOLLWRNORM: EPOLL_EVENTS = 256;
pub const EPOLL_EVENTS_EPOLLWRBAND: EPOLL_EVENTS = 512;
pub const EPOLL_EVENTS_EPOLLMSG: EPOLL_EVENTS = 1024;
pub const EPOLL_EVENTS_EPOLLERR: EPOLL_EVENTS = 8;
pub const EPOLL_EVENTS_EPOLLHUP: EPOLL_EVENTS = 16;
pub const EPOLL_EVENTS_EPOLLRDHUP: EPOLL_EVENTS = 8192;
pub const EPOLL_EVENTS_EPOLLEXCLUSIVE: EPOLL_EVENTS = 268435456;
pub const EPOLL_EVENTS_EPOLLWAKEUP: EPOLL_EVENTS = 536870912;
pub const EPOLL_EVENTS_EPOLLONESHOT: EPOLL_EVENTS = 1073741824;
pub const EPOLL_EVENTS_EPOLLET: EPOLL_EVENTS = 2147483648;
pub type EPOLL_EVENTS = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union epoll_data {
    pub ptr: *mut ::std::os::raw::c_void,
    pub fd: ::std::os::raw::c_int,
    pub u32_: u32,
    pub u64_: u64,
}
#[test]
fn bindgen_test_layout_epoll_data() {
    assert_eq!(
        ::std::mem::size_of::<epoll_data>(),
        8usize,
        concat!("Size of: ", stringify!(epoll_data))
    );
    assert_eq!(
        ::std::mem::align_of::<epoll_data>(),
        8usize,
        concat!("Alignment of ", stringify!(epoll_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<epoll_data>())).ptr as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(epoll_data),
        "::",
        stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<epoll_data>())).fd as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(epoll_data),
        "::",
        stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<epoll_data>())).u32_ as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(epoll_data),
        "::",
        stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<epoll_data>())).u64_ as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(epoll_data),
        "::",
        stringify!(u64_)
        )
    );
}
pub type epoll_data_t = epoll_data;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct epoll_event {
    pub events: u32,
    pub data: epoll_data_t,
}
#[test]
fn bindgen_test_layout_epoll_event() {
    assert_eq!(
        ::std::mem::size_of::<epoll_event>(),
        12usize,
        concat!("Size of: ", stringify!(epoll_event))
    );
    assert_eq!(
        ::std::mem::align_of::<epoll_event>(),
        1usize,
        concat!("Alignment of ", stringify!(epoll_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<epoll_event>())).events as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(epoll_event),
        "::",
        stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<epoll_event>())).data as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(epoll_event),
        "::",
        stringify!(data)
        )
    );
}
extern "C" {
    pub fn epoll_create(__size: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn epoll_create1(__flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn epoll_ctl(
        __epfd: ::std::os::raw::c_int,
        __op: ::std::os::raw::c_int,
        __fd: ::std::os::raw::c_int,
        __event: *mut epoll_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn epoll_wait(
        __epfd: ::std::os::raw::c_int,
        __events: *mut epoll_event,
        __maxevents: ::std::os::raw::c_int,
        __timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn epoll_pwait(
        __epfd: ::std::os::raw::c_int,
        __events: *mut epoll_event,
        __maxevents: ::std::os::raw::c_int,
        __timeout: ::std::os::raw::c_int,
        __ss: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zf_muxer_set {
    _unused: [u8; 0],
}
extern "C" {
    pub fn zf_muxer_alloc(
        stack: *mut zf_stack,
        muxer_out: *mut *mut zf_muxer_set,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_muxer_free(muxer: *mut zf_muxer_set);
}
extern "C" {
    pub fn zf_muxer_add(
        muxer: *mut zf_muxer_set,
        w: *mut zf_waitable,
        event: *const epoll_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_muxer_mod(w: *mut zf_waitable, event: *const epoll_event) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_muxer_del(w: *mut zf_waitable) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_muxer_wait(
        muxer: *mut zf_muxer_set,
        events: *mut epoll_event,
        maxevents: ::std::os::raw::c_int,
        timeout_ns: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_waitable_event(w: *mut zf_waitable) -> *const epoll_event;
}
extern "C" {
    pub fn zf_waitable_fd_get(
        stack: *mut zf_stack,
        fd: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_waitable_fd_prime(stack: *mut zf_stack) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_attr_alloc(attr_out: *mut *mut zf_attr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_attr_free(attr: *mut zf_attr);
}
extern "C" {
    pub fn zf_attr_reset(attr: *mut zf_attr);
}
extern "C" {
    pub fn zf_attr_set_int(
        attr: *mut zf_attr,
        name: *const ::std::os::raw::c_char,
        val: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_attr_get_int(
        attr: *mut zf_attr,
        name: *const ::std::os::raw::c_char,
        val: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_attr_set_str(
        attr: *mut zf_attr,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_attr_get_str(
        attr: *mut zf_attr,
        name: *const ::std::os::raw::c_char,
        val: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_attr_set_from_str(
        attr: *mut zf_attr,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_attr_set_from_fmt(
        attr: *mut zf_attr,
        name: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_attr_dup(attr: *const zf_attr) -> *mut zf_attr;
}
extern "C" {
    pub fn zf_attr_doc(
        attr_name_opt: *const ::std::os::raw::c_char,
        docs_out: *mut *mut *const ::std::os::raw::c_char,
        docs_len_out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type socklen_t = __socklen_t;
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
pub const __socket_type_SOCK_RAW: __socket_type = 3;
pub const __socket_type_SOCK_RDM: __socket_type = 4;
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
pub type __socket_type = ::std::os::raw::c_uint;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(sockaddr),
        "::",
        stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
        "Offset of field: ",
        stringify!(sockaddr),
        "::",
        stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(sockaddr_storage),
        "::",
        stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_padding as *const _ as usize },
        2usize,
        concat!(
        "Offset of field: ",
        stringify!(sockaddr_storage),
        "::",
        stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        120usize,
        concat!(
        "Offset of field: ",
        stringify!(sockaddr_storage),
        "::",
        stringify!(__ss_align)
        )
    );
}
pub const MSG_OOB: ::std::os::raw::c_uint = 1;
pub const MSG_PEEK: ::std::os::raw::c_uint = 2;
pub const MSG_DONTROUTE: ::std::os::raw::c_uint = 4;
pub const MSG_CTRUNC: ::std::os::raw::c_uint = 8;
pub const MSG_PROXY: ::std::os::raw::c_uint = 16;
pub const MSG_TRUNC: ::std::os::raw::c_uint = 32;
pub const MSG_DONTWAIT: ::std::os::raw::c_uint = 64;
pub const MSG_EOR: ::std::os::raw::c_uint = 128;
pub const MSG_WAITALL: ::std::os::raw::c_uint = 256;
pub const MSG_FIN: ::std::os::raw::c_uint = 512;
pub const MSG_SYN: ::std::os::raw::c_uint = 1024;
pub const MSG_CONFIRM: ::std::os::raw::c_uint = 2048;
pub const MSG_RST: ::std::os::raw::c_uint = 4096;
pub const MSG_ERRQUEUE: ::std::os::raw::c_uint = 8192;
pub const MSG_NOSIGNAL: ::std::os::raw::c_uint = 16384;
pub const MSG_MORE: ::std::os::raw::c_uint = 32768;
pub const MSG_WAITFORONE: ::std::os::raw::c_uint = 65536;
pub const MSG_BATCH: ::std::os::raw::c_uint = 262144;
pub const MSG_ZEROCOPY: ::std::os::raw::c_uint = 67108864;
pub const MSG_FASTOPEN: ::std::os::raw::c_uint = 536870912;
pub const MSG_CMSG_CLOEXEC: ::std::os::raw::c_uint = 1073741824;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: size_t,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: size_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(msghdr),
        "::",
        stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(msghdr),
        "::",
        stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iov as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(msghdr),
        "::",
        stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(msghdr),
        "::",
        stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_control as *const _ as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(msghdr),
        "::",
        stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(msghdr),
        "::",
        stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
        48usize,
        concat!(
        "Offset of field: ",
        stringify!(msghdr),
        "::",
        stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cmsghdr {
    pub cmsg_len: size_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_len as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(cmsghdr),
        "::",
        stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_level as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(cmsghdr),
        "::",
        stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_type as *const _ as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(cmsghdr),
        "::",
        stringify!(cmsg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).__cmsg_data as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(cmsghdr),
        "::",
        stringify!(__cmsg_data)
        )
    );
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
pub const SCM_RIGHTS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_onoff as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(linger),
        "::",
        stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_linger as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(linger),
        "::",
        stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    assert_eq!(
        ::std::mem::size_of::<osockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(osockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<osockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(osockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<osockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(osockaddr),
        "::",
        stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<osockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
        "Offset of field: ",
        stringify!(osockaddr),
        "::",
        stringify!(sa_data)
        )
    );
}
pub const SHUT_RD: ::std::os::raw::c_uint = 0;
pub const SHUT_WR: ::std::os::raw::c_uint = 1;
pub const SHUT_RDWR: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
extern "C" {
    pub fn socket(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
        __flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: size_t,
        __flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
        __flags: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __addr_len: socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: size_t,
        __flags: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __message: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __message: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *mut ::std::os::raw::c_void,
        __optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *const ::std::os::raw::c_void,
        __optlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isfdtype(
        __fd: ::std::os::raw::c_int,
        __fdtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(in_addr),
        "::",
        stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_dst as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_opts),
        "::",
        stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_opts as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_opts),
        "::",
        stringify!(ip_opts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_mreqn),
        "::",
        stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_address as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_mreqn),
        "::",
        stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_ifindex as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_mreqn),
        "::",
        stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_ifindex as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(in_pktinfo),
        "::",
        stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_spec_dst as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(in_pktinfo),
        "::",
        stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_addr as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(in_pktinfo),
        "::",
        stringify!(ipi_addr)
        )
    );
}
pub const IPPROTO_IP: ::std::os::raw::c_uint = 0;
pub const IPPROTO_ICMP: ::std::os::raw::c_uint = 1;
pub const IPPROTO_IGMP: ::std::os::raw::c_uint = 2;
pub const IPPROTO_IPIP: ::std::os::raw::c_uint = 4;
pub const IPPROTO_TCP: ::std::os::raw::c_uint = 6;
pub const IPPROTO_EGP: ::std::os::raw::c_uint = 8;
pub const IPPROTO_PUP: ::std::os::raw::c_uint = 12;
pub const IPPROTO_UDP: ::std::os::raw::c_uint = 17;
pub const IPPROTO_IDP: ::std::os::raw::c_uint = 22;
pub const IPPROTO_TP: ::std::os::raw::c_uint = 29;
pub const IPPROTO_DCCP: ::std::os::raw::c_uint = 33;
pub const IPPROTO_IPV6: ::std::os::raw::c_uint = 41;
pub const IPPROTO_RSVP: ::std::os::raw::c_uint = 46;
pub const IPPROTO_GRE: ::std::os::raw::c_uint = 47;
pub const IPPROTO_ESP: ::std::os::raw::c_uint = 50;
pub const IPPROTO_AH: ::std::os::raw::c_uint = 51;
pub const IPPROTO_MTP: ::std::os::raw::c_uint = 92;
pub const IPPROTO_BEETPH: ::std::os::raw::c_uint = 94;
pub const IPPROTO_ENCAP: ::std::os::raw::c_uint = 98;
pub const IPPROTO_PIM: ::std::os::raw::c_uint = 103;
pub const IPPROTO_COMP: ::std::os::raw::c_uint = 108;
pub const IPPROTO_SCTP: ::std::os::raw::c_uint = 132;
pub const IPPROTO_UDPLITE: ::std::os::raw::c_uint = 136;
pub const IPPROTO_MPLS: ::std::os::raw::c_uint = 137;
pub const IPPROTO_RAW: ::std::os::raw::c_uint = 255;
pub const IPPROTO_MAX: ::std::os::raw::c_uint = 256;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const IPPROTO_HOPOPTS: ::std::os::raw::c_uint = 0;
pub const IPPROTO_ROUTING: ::std::os::raw::c_uint = 43;
pub const IPPROTO_FRAGMENT: ::std::os::raw::c_uint = 44;
pub const IPPROTO_ICMPV6: ::std::os::raw::c_uint = 58;
pub const IPPROTO_NONE: ::std::os::raw::c_uint = 59;
pub const IPPROTO_DSTOPTS: ::std::os::raw::c_uint = 60;
pub const IPPROTO_MH: ::std::os::raw::c_uint = 135;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub type in_port_t = u16;
pub const IPPORT_ECHO: ::std::os::raw::c_uint = 7;
pub const IPPORT_DISCARD: ::std::os::raw::c_uint = 9;
pub const IPPORT_SYSTAT: ::std::os::raw::c_uint = 11;
pub const IPPORT_DAYTIME: ::std::os::raw::c_uint = 13;
pub const IPPORT_NETSTAT: ::std::os::raw::c_uint = 15;
pub const IPPORT_FTP: ::std::os::raw::c_uint = 21;
pub const IPPORT_TELNET: ::std::os::raw::c_uint = 23;
pub const IPPORT_SMTP: ::std::os::raw::c_uint = 25;
pub const IPPORT_TIMESERVER: ::std::os::raw::c_uint = 37;
pub const IPPORT_NAMESERVER: ::std::os::raw::c_uint = 42;
pub const IPPORT_WHOIS: ::std::os::raw::c_uint = 43;
pub const IPPORT_MTP: ::std::os::raw::c_uint = 57;
pub const IPPORT_TFTP: ::std::os::raw::c_uint = 69;
pub const IPPORT_RJE: ::std::os::raw::c_uint = 77;
pub const IPPORT_FINGER: ::std::os::raw::c_uint = 79;
pub const IPPORT_TTYLINK: ::std::os::raw::c_uint = 87;
pub const IPPORT_SUPDUP: ::std::os::raw::c_uint = 95;
pub const IPPORT_EXECSERVER: ::std::os::raw::c_uint = 512;
pub const IPPORT_LOGINSERVER: ::std::os::raw::c_uint = 513;
pub const IPPORT_CMDSERVER: ::std::os::raw::c_uint = 514;
pub const IPPORT_EFSSERVER: ::std::os::raw::c_uint = 520;
pub const IPPORT_BIFFUDP: ::std::os::raw::c_uint = 512;
pub const IPPORT_WHOSERVER: ::std::os::raw::c_uint = 513;
pub const IPPORT_ROUTESERVER: ::std::os::raw::c_uint = 520;
pub const IPPORT_RESERVED: ::std::os::raw::c_uint = 1024;
pub const IPPORT_USERRESERVED: ::std::os::raw::c_uint = 5000;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(in6_addr__bindgen_ty_1),
        "::",
        stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(in6_addr__bindgen_ty_1),
        "::",
        stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(in6_addr__bindgen_ty_1),
        "::",
        stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).__in6_u as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(in6_addr),
        "::",
        stringify!(__in6_u)
        )
    );
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(sockaddr_in),
        "::",
        stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
        "Offset of field: ",
        stringify!(sockaddr_in),
        "::",
        stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(sockaddr_in),
        "::",
        stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(sockaddr_in),
        "::",
        stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(sockaddr_in6),
        "::",
        stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
        "Offset of field: ",
        stringify!(sockaddr_in6),
        "::",
        stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(sockaddr_in6),
        "::",
        stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(sockaddr_in6),
        "::",
        stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(sockaddr_in6),
        "::",
        stringify!(sin6_scope_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_mreq),
        "::",
        stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_mreq),
        "::",
        stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_mreq_source),
        "::",
        stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_mreq_source),
        "::",
        stringify!(imr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_sourceaddr as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_mreq_source),
        "::",
        stringify!(imr_sourceaddr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_multiaddr as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ipv6_mreq),
        "::",
        stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_interface as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(ipv6_mreq),
        "::",
        stringify!(ipv6mr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        136usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_req>())).gr_interface as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(group_req),
        "::",
        stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_req>())).gr_group as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(group_req),
        "::",
        stringify!(gr_group)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        264usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_interface as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(group_source_req),
        "::",
        stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_group as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(group_source_req),
        "::",
        stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_source as *const _ as usize },
        136usize,
        concat!(
        "Offset of field: ",
        stringify!(group_source_req),
        "::",
        stringify!(gsr_source)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    assert_eq!(
        ::std::mem::size_of::<ip_msfilter>(),
        20usize,
        concat!("Size of: ", stringify!(ip_msfilter))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_msfilter>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_msfilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_multiaddr as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_msfilter),
        "::",
        stringify!(imsf_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_interface as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_msfilter),
        "::",
        stringify!(imsf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_fmode as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_msfilter),
        "::",
        stringify!(imsf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_numsrc as *const _ as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_msfilter),
        "::",
        stringify!(imsf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_slist as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_msfilter),
        "::",
        stringify!(imsf_slist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    assert_eq!(
        ::std::mem::size_of::<group_filter>(),
        272usize,
        concat!("Size of: ", stringify!(group_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<group_filter>(),
        8usize,
        concat!("Alignment of ", stringify!(group_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_interface as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(group_filter),
        "::",
        stringify!(gf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_group as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(group_filter),
        "::",
        stringify!(gf_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_fmode as *const _ as usize },
        136usize,
        concat!(
        "Offset of field: ",
        stringify!(group_filter),
        "::",
        stringify!(gf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_numsrc as *const _ as usize },
        140usize,
        concat!(
        "Offset of field: ",
        stringify!(group_filter),
        "::",
        stringify!(gf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_slist as *const _ as usize },
        144usize,
        concat!(
        "Offset of field: ",
        stringify!(group_filter),
        "::",
        stringify!(gf_slist)
        )
    );
}
extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    pub fn bindresvport(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport6(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in6,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timestamp {
    pub len: u8,
    pub ptr: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub data: [u32; 9usize],
}
#[test]
fn bindgen_test_layout_timestamp() {
    assert_eq!(
        ::std::mem::size_of::<timestamp>(),
        40usize,
        concat!("Size of: ", stringify!(timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<timestamp>(),
        4usize,
        concat!("Alignment of ", stringify!(timestamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timestamp>())).len as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(timestamp),
        "::",
        stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timestamp>())).ptr as *const _ as usize },
        1usize,
        concat!(
        "Offset of field: ",
        stringify!(timestamp),
        "::",
        stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timestamp>())).data as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(timestamp),
        "::",
        stringify!(data)
        )
    );
}
impl timestamp {
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn overflow(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_overflow(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: ::std::os::raw::c_uint,
        overflow: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let overflow: u32 = unsafe { ::std::mem::transmute(overflow) };
            overflow as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iphdr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tos: u8,
    pub tot_len: u16,
    pub id: u16,
    pub frag_off: u16,
    pub ttl: u8,
    pub protocol: u8,
    pub check: u16,
    pub saddr: u32,
    pub daddr: u32,
}
#[test]
fn bindgen_test_layout_iphdr() {
    assert_eq!(
        ::std::mem::size_of::<iphdr>(),
        20usize,
        concat!("Size of: ", stringify!(iphdr))
    );
    assert_eq!(
        ::std::mem::align_of::<iphdr>(),
        4usize,
        concat!("Alignment of ", stringify!(iphdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).tos as *const _ as usize },
        1usize,
        concat!(
        "Offset of field: ",
        stringify!(iphdr),
        "::",
        stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).tot_len as *const _ as usize },
        2usize,
        concat!(
        "Offset of field: ",
        stringify!(iphdr),
        "::",
        stringify!(tot_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).id as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(iphdr), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).frag_off as *const _ as usize },
        6usize,
        concat!(
        "Offset of field: ",
        stringify!(iphdr),
        "::",
        stringify!(frag_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).ttl as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(iphdr),
        "::",
        stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).protocol as *const _ as usize },
        9usize,
        concat!(
        "Offset of field: ",
        stringify!(iphdr),
        "::",
        stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).check as *const _ as usize },
        10usize,
        concat!(
        "Offset of field: ",
        stringify!(iphdr),
        "::",
        stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).saddr as *const _ as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(iphdr),
        "::",
        stringify!(saddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).daddr as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(iphdr),
        "::",
        stringify!(daddr)
        )
    );
}
impl iphdr {
    #[inline]
    pub fn ihl(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ihl(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ihl: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ihl: u32 = unsafe { ::std::mem::transmute(ihl) };
            ihl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ip_tos: u8,
    pub ip_len: ::std::os::raw::c_ushort,
    pub ip_id: ::std::os::raw::c_ushort,
    pub ip_off: ::std::os::raw::c_ushort,
    pub ip_ttl: u8,
    pub ip_p: u8,
    pub ip_sum: ::std::os::raw::c_ushort,
    pub ip_src: in_addr,
    pub ip_dst: in_addr,
}
#[test]
fn bindgen_test_layout_ip() {
    assert_eq!(
        ::std::mem::size_of::<ip>(),
        20usize,
        concat!("Size of: ", stringify!(ip))
    );
    assert_eq!(
        ::std::mem::align_of::<ip>(),
        4usize,
        concat!("Alignment of ", stringify!(ip))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_tos as *const _ as usize },
        1usize,
        concat!(
        "Offset of field: ",
        stringify!(ip),
        "::",
        stringify!(ip_tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_len as *const _ as usize },
        2usize,
        concat!(
        "Offset of field: ",
        stringify!(ip),
        "::",
        stringify!(ip_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_id as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(ip), "::", stringify!(ip_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_off as *const _ as usize },
        6usize,
        concat!(
        "Offset of field: ",
        stringify!(ip),
        "::",
        stringify!(ip_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_ttl as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(ip),
        "::",
        stringify!(ip_ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_p as *const _ as usize },
        9usize,
        concat!("Offset of field: ", stringify!(ip), "::", stringify!(ip_p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_sum as *const _ as usize },
        10usize,
        concat!(
        "Offset of field: ",
        stringify!(ip),
        "::",
        stringify!(ip_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_src as *const _ as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(ip),
        "::",
        stringify!(ip_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_dst as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(ip),
        "::",
        stringify!(ip_dst)
        )
    );
}
impl ip {
    #[inline]
    pub fn ip_hl(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ip_hl(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_v(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ip_v(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ip_hl: ::std::os::raw::c_uint,
        ip_v: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ip_hl: u32 = unsafe { ::std::mem::transmute(ip_hl) };
            ip_hl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ip_v: u32 = unsafe { ::std::mem::transmute(ip_v) };
            ip_v as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_timestamp {
    pub ipt_code: u8,
    pub ipt_len: u8,
    pub ipt_ptr: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub data: [u32; 9usize],
}
#[test]
fn bindgen_test_layout_ip_timestamp() {
    assert_eq!(
        ::std::mem::size_of::<ip_timestamp>(),
        40usize,
        concat!("Size of: ", stringify!(ip_timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_timestamp>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_timestamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_timestamp>())).ipt_code as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_timestamp),
        "::",
        stringify!(ipt_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_timestamp>())).ipt_len as *const _ as usize },
        1usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_timestamp),
        "::",
        stringify!(ipt_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_timestamp>())).ipt_ptr as *const _ as usize },
        2usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_timestamp),
        "::",
        stringify!(ipt_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_timestamp>())).data as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(ip_timestamp),
        "::",
        stringify!(data)
        )
    );
}
impl ip_timestamp {
    #[inline]
    pub fn ipt_flg(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ipt_flg(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ipt_oflw(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ipt_oflw(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ipt_flg: ::std::os::raw::c_uint,
        ipt_oflw: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ipt_flg: u32 = unsafe { ::std::mem::transmute(ipt_flg) };
            ipt_flg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ipt_oflw: u32 = unsafe { ::std::mem::transmute(ipt_oflw) };
            ipt_oflw as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct udphdr {
    pub __bindgen_anon_1: udphdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union udphdr__bindgen_ty_1 {
    pub __bindgen_anon_1: udphdr__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: udphdr__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udphdr__bindgen_ty_1__bindgen_ty_1 {
    pub uh_sport: u16,
    pub uh_dport: u16,
    pub uh_ulen: u16,
    pub uh_sum: u16,
}
#[test]
fn bindgen_test_layout_udphdr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<udphdr__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(udphdr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<udphdr__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
        "Alignment of ",
        stringify!(udphdr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<udphdr__bindgen_ty_1__bindgen_ty_1>())).uh_sport as *const _
                as usize
        },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(udphdr__bindgen_ty_1__bindgen_ty_1),
        "::",
        stringify!(uh_sport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<udphdr__bindgen_ty_1__bindgen_ty_1>())).uh_dport as *const _
                as usize
        },
        2usize,
        concat!(
        "Offset of field: ",
        stringify!(udphdr__bindgen_ty_1__bindgen_ty_1),
        "::",
        stringify!(uh_dport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<udphdr__bindgen_ty_1__bindgen_ty_1>())).uh_ulen as *const _
                as usize
        },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(udphdr__bindgen_ty_1__bindgen_ty_1),
        "::",
        stringify!(uh_ulen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<udphdr__bindgen_ty_1__bindgen_ty_1>())).uh_sum as *const _
                as usize
        },
        6usize,
        concat!(
        "Offset of field: ",
        stringify!(udphdr__bindgen_ty_1__bindgen_ty_1),
        "::",
        stringify!(uh_sum)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udphdr__bindgen_ty_1__bindgen_ty_2 {
    pub source: u16,
    pub dest: u16,
    pub len: u16,
    pub check: u16,
}
#[test]
fn bindgen_test_layout_udphdr__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<udphdr__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(udphdr__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<udphdr__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
        "Alignment of ",
        stringify!(udphdr__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<udphdr__bindgen_ty_1__bindgen_ty_2>())).source as *const _
                as usize
        },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(udphdr__bindgen_ty_1__bindgen_ty_2),
        "::",
        stringify!(source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<udphdr__bindgen_ty_1__bindgen_ty_2>())).dest as *const _ as usize
        },
        2usize,
        concat!(
        "Offset of field: ",
        stringify!(udphdr__bindgen_ty_1__bindgen_ty_2),
        "::",
        stringify!(dest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<udphdr__bindgen_ty_1__bindgen_ty_2>())).len as *const _ as usize
        },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(udphdr__bindgen_ty_1__bindgen_ty_2),
        "::",
        stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<udphdr__bindgen_ty_1__bindgen_ty_2>())).check as *const _
                as usize
        },
        6usize,
        concat!(
        "Offset of field: ",
        stringify!(udphdr__bindgen_ty_1__bindgen_ty_2),
        "::",
        stringify!(check)
        )
    );
}
#[test]
fn bindgen_test_layout_udphdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<udphdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(udphdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<udphdr__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(udphdr__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_udphdr() {
    assert_eq!(
        ::std::mem::size_of::<udphdr>(),
        8usize,
        concat!("Size of: ", stringify!(udphdr))
    );
    assert_eq!(
        ::std::mem::align_of::<udphdr>(),
        2usize,
        concat!("Alignment of ", stringify!(udphdr))
    );
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zfur {}
#[test]
fn bindgen_test_layout_zfur() {
    assert_eq!(
        ::std::mem::size_of::<zfur>(),
        0usize,
        concat!("Size of: ", stringify!(zfur))
    );
    assert_eq!(
        ::std::mem::align_of::<zfur>(),
        1usize,
        concat!("Alignment of ", stringify!(zfur))
    );
}
extern "C" {
    pub fn zfur_alloc(
        us_out: *mut *mut zfur,
        st: *mut zf_stack,
        attr: *const zf_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zfur_free(us: *mut zfur) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zfur_addr_bind(
        us: *mut zfur,
        laddr: *mut sockaddr,
        laddrlen: socklen_t,
        raddr: *const sockaddr,
        raddrlen: socklen_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zfur_addr_unbind(
        us: *mut zfur,
        laddr: *const sockaddr,
        laddrlen: socklen_t,
        raddr: *const sockaddr,
        raddrlen: socklen_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug)]
pub struct zfur_msg {
    pub reserved: [::std::os::raw::c_int; 4usize],
    pub dgrams_left: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub iovcnt: ::std::os::raw::c_int,
    pub iov: __IncompleteArrayField<iovec>,
}
#[test]
fn bindgen_test_layout_zfur_msg() {
    assert_eq!(
        ::std::mem::size_of::<zfur_msg>(),
        32usize,
        concat!("Size of: ", stringify!(zfur_msg))
    );
    assert_eq!(
        ::std::mem::align_of::<zfur_msg>(),
        8usize,
        concat!("Alignment of ", stringify!(zfur_msg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zfur_msg>())).reserved as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(zfur_msg),
        "::",
        stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zfur_msg>())).dgrams_left as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(zfur_msg),
        "::",
        stringify!(dgrams_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zfur_msg>())).flags as *const _ as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(zfur_msg),
        "::",
        stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zfur_msg>())).iovcnt as *const _ as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(zfur_msg),
        "::",
        stringify!(iovcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zfur_msg>())).iov as *const _ as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(zfur_msg),
        "::",
        stringify!(iov)
        )
    );
}
extern "C" {
    pub fn zfur_zc_recv(us: *mut zfur, msg: *mut zfur_msg, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn zfur_zc_recv_done(us: *mut zfur, msg: *mut zfur_msg);
}
extern "C" {
    pub fn zfur_pkt_get_header(
        us: *mut zfur,
        msg: *const zfur_msg,
        iphdr: *mut *const iphdr,
        udphdr: *mut *const udphdr,
        pktind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zfur_pkt_get_timestamp(
        us: *mut zfur,
        msg: *const zfur_msg,
        ts_out: *mut timespec,
        pktind: ::std::os::raw::c_int,
        flags: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zfur_to_waitable(us: *mut zfur) -> *mut zf_waitable;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zfut {}
#[test]
fn bindgen_test_layout_zfut() {
    assert_eq!(
        ::std::mem::size_of::<zfut>(),
        0usize,
        concat!("Size of: ", stringify!(zfut))
    );
    assert_eq!(
        ::std::mem::align_of::<zfut>(),
        1usize,
        concat!("Alignment of ", stringify!(zfut))
    );
}
extern "C" {
    pub fn zfut_alloc(
        us_out: *mut *mut zfut,
        st: *mut zf_stack,
        laddr: *const sockaddr,
        laddrlen: socklen_t,
        raddr: *const sockaddr,
        raddrlen: socklen_t,
        flags: ::std::os::raw::c_int,
        attr: *const zf_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zfut_free(us: *mut zfut) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zfut_get_mss(us: *mut zfut) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zfut_send_single(
        us: *mut zfut,
        buf: *const ::std::os::raw::c_void,
        buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zfut_send_single_warm(
        us: *mut zfut,
        buf: *const ::std::os::raw::c_void,
        buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zfut_send(
        us: *mut zfut,
        iov: *const iovec,
        iov_cnt: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zfut_get_tx_timestamps(
        us: *mut zfut,
        reports_out: *mut zf_pkt_report,
        count_in_out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zfut_to_waitable(us: *mut zfut) -> *mut zf_waitable;
}
extern "C" {
    pub fn zfut_get_header_size(us: *mut zfut) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zftl {}
#[test]
fn bindgen_test_layout_zftl() {
    assert_eq!(
        ::std::mem::size_of::<zftl>(),
        0usize,
        concat!("Size of: ", stringify!(zftl))
    );
    assert_eq!(
        ::std::mem::align_of::<zftl>(),
        1usize,
        concat!("Alignment of ", stringify!(zftl))
    );
}
extern "C" {
    pub fn zftl_listen(
        st: *mut zf_stack,
        laddr: *const sockaddr,
        laddrlen: socklen_t,
        attr: *const zf_attr,
        tl_out: *mut *mut zftl,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zftl_accept(tl: *mut zftl, ts_out: *mut *mut zft) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zftl_to_waitable(tl: *mut zftl) -> *mut zf_waitable;
}
extern "C" {
    pub fn zftl_getname(ts: *mut zftl, laddr_out: *mut sockaddr, laddrlen: *mut socklen_t);
}
extern "C" {
    pub fn zftl_free(ts: *mut zftl) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zft_handle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zft {}
#[test]
fn bindgen_test_layout_zft() {
    assert_eq!(
        ::std::mem::size_of::<zft>(),
        0usize,
        concat!("Size of: ", stringify!(zft))
    );
    assert_eq!(
        ::std::mem::align_of::<zft>(),
        1usize,
        concat!("Alignment of ", stringify!(zft))
    );
}
extern "C" {
    pub fn zft_to_waitable(ts: *mut zft) -> *mut zf_waitable;
}
extern "C" {
    pub fn zft_alloc(
        st: *mut zf_stack,
        attr: *const zf_attr,
        handle_out: *mut *mut zft_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zft_handle_free(handle: *mut zft_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zft_handle_getname(
        ts: *mut zft_handle,
        laddr_out: *mut sockaddr,
        laddrlen: *mut socklen_t,
    );
}
extern "C" {
    pub fn zft_addr_bind(
        handle: *mut zft_handle,
        laddr: *const sockaddr,
        laddrlen: socklen_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zft_connect(
        handle: *mut zft_handle,
        raddr: *const sockaddr,
        raddrlen: socklen_t,
        ts_out: *mut *mut zft,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zft_shutdown_tx(ts: *mut zft) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zft_free(ts: *mut zft) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zft_state(ts: *mut zft) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zft_error(ts: *mut zft) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zft_getname(
        ts: *mut zft,
        laddr_out: *mut sockaddr,
        laddrlen: *mut socklen_t,
        raddr_out: *mut sockaddr,
        raddrlen: *mut socklen_t,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct zft_msg {
    pub reserved: [::std::os::raw::c_int; 4usize],
    pub pkts_left: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub iovcnt: ::std::os::raw::c_int,
    pub iov: __IncompleteArrayField<iovec>,
}
#[test]
fn bindgen_test_layout_zft_msg() {
    assert_eq!(
        ::std::mem::size_of::<zft_msg>(),
        32usize,
        concat!("Size of: ", stringify!(zft_msg))
    );
    assert_eq!(
        ::std::mem::align_of::<zft_msg>(),
        8usize,
        concat!("Alignment of ", stringify!(zft_msg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zft_msg>())).reserved as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(zft_msg),
        "::",
        stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zft_msg>())).pkts_left as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(zft_msg),
        "::",
        stringify!(pkts_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zft_msg>())).flags as *const _ as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(zft_msg),
        "::",
        stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zft_msg>())).iovcnt as *const _ as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(zft_msg),
        "::",
        stringify!(iovcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zft_msg>())).iov as *const _ as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(zft_msg),
        "::",
        stringify!(iov)
        )
    );
}
extern "C" {
    pub fn zft_zc_recv(ts: *mut zft, msg: *mut zft_msg, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn zft_zc_recv_done(ts: *mut zft, msg: *mut zft_msg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zft_zc_recv_done_some(
        ts: *mut zft,
        msg: *mut zft_msg,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zft_recv(
        ts: *mut zft,
        iov: *const iovec,
        iovcnt: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zft_pkt_get_timestamp(
        ts: *mut zft,
        msg: *const zft_msg,
        ts_out: *mut timespec,
        pktind: ::std::os::raw::c_int,
        flags: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zft_send(
        ts: *mut zft,
        iov: *const iovec,
        iov_cnt: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn zft_send_single(
        ts: *mut zft,
        buf: *const ::std::os::raw::c_void,
        buflen: size_t,
        flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn zft_send_single_warm(
        ts: *mut zft,
        buf: *const ::std::os::raw::c_void,
        buflen: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn zft_send_space(ts: *mut zft, space: *mut size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zft_get_mss(ts: *mut zft) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zft_get_header_size(ts: *mut zft) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn zft_get_tx_timestamps(
        ts: *mut zft,
        reports: *mut zf_pkt_report,
        count_in_out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_reactor_perform(st: *mut zf_stack) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_reactor_perform_attr(
        st: *mut zf_stack,
        attr: *const zf_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_stack_has_pending_work(st: *const zf_stack) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_stack_has_pending_events(st: *const zf_stack) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zf_pkt_report {
    pub timestamp: timespec,
    pub start: u32,
    pub bytes: u16,
    pub flags: u16,
}
#[test]
fn bindgen_test_layout_zf_pkt_report() {
    assert_eq!(
        ::std::mem::size_of::<zf_pkt_report>(),
        24usize,
        concat!("Size of: ", stringify!(zf_pkt_report))
    );
    assert_eq!(
        ::std::mem::align_of::<zf_pkt_report>(),
        8usize,
        concat!("Alignment of ", stringify!(zf_pkt_report))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zf_pkt_report>())).timestamp as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(zf_pkt_report),
        "::",
        stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zf_pkt_report>())).start as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(zf_pkt_report),
        "::",
        stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zf_pkt_report>())).bytes as *const _ as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(zf_pkt_report),
        "::",
        stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zf_pkt_report>())).flags as *const _ as usize },
        22usize,
        concat!(
        "Offset of field: ",
        stringify!(zf_pkt_report),
        "::",
        stringify!(flags)
        )
    );
}
pub const zf_zc_flags_ZF_OVERLAPPED_WAIT: zf_zc_flags = 65536;
pub const zf_zc_flags_ZF_OVERLAPPED_COMPLETE: zf_zc_flags = 131072;
pub type zf_zc_flags = ::std::os::raw::c_uint;
pub type zf_althandle = u64;
extern "C" {
    pub fn zf_alternatives_alloc(
        stack: *mut zf_stack,
        attr: *const zf_attr,
        alt_out: *mut zf_althandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_alternatives_release(
        stack: *mut zf_stack,
        alt: zf_althandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_alternatives_send(stack: *mut zf_stack, alt: zf_althandle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_alternatives_cancel(stack: *mut zf_stack, alt: zf_althandle)
                                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zft_alternatives_queue(
        ts: *mut zft,
        alt: zf_althandle,
        iov: *const iovec,
        iov_cnt: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_alternatives_free_space(
        stack: *mut zf_stack,
        alt: zf_althandle,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn zf_alternatives_query_overhead_tcp(
        ts: *mut zft,
        out: *mut ef_vi_transmit_alt_overhead,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zf_ds {
    pub headers: *mut ::std::os::raw::c_void,
    pub headers_size: ::std::os::raw::c_int,
    pub headers_len: ::std::os::raw::c_int,
    pub mss: ::std::os::raw::c_int,
    pub send_wnd: ::std::os::raw::c_int,
    pub cong_wnd: ::std::os::raw::c_int,
    pub delegated_wnd: ::std::os::raw::c_int,
    pub tcp_seq_offset: ::std::os::raw::c_int,
    pub ip_len_offset: ::std::os::raw::c_int,
    pub ip_tcp_hdr_len: ::std::os::raw::c_int,
    pub reserved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_zf_ds() {
    assert_eq!(
        ::std::mem::size_of::<zf_ds>(),
        48usize,
        concat!("Size of: ", stringify!(zf_ds))
    );
    assert_eq!(
        ::std::mem::align_of::<zf_ds>(),
        8usize,
        concat!("Alignment of ", stringify!(zf_ds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zf_ds>())).headers as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(zf_ds),
        "::",
        stringify!(headers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zf_ds>())).headers_size as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(zf_ds),
        "::",
        stringify!(headers_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zf_ds>())).headers_len as *const _ as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(zf_ds),
        "::",
        stringify!(headers_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zf_ds>())).mss as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(zf_ds),
        "::",
        stringify!(mss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zf_ds>())).send_wnd as *const _ as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(zf_ds),
        "::",
        stringify!(send_wnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zf_ds>())).cong_wnd as *const _ as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(zf_ds),
        "::",
        stringify!(cong_wnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zf_ds>())).delegated_wnd as *const _ as usize },
        28usize,
        concat!(
        "Offset of field: ",
        stringify!(zf_ds),
        "::",
        stringify!(delegated_wnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zf_ds>())).tcp_seq_offset as *const _ as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(zf_ds),
        "::",
        stringify!(tcp_seq_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zf_ds>())).ip_len_offset as *const _ as usize },
        36usize,
        concat!(
        "Offset of field: ",
        stringify!(zf_ds),
        "::",
        stringify!(ip_len_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zf_ds>())).ip_tcp_hdr_len as *const _ as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(zf_ds),
        "::",
        stringify!(ip_tcp_hdr_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zf_ds>())).reserved as *const _ as usize },
        44usize,
        concat!(
        "Offset of field: ",
        stringify!(zf_ds),
        "::",
        stringify!(reserved)
        )
    );
}
pub const zf_delegated_send_rc_ZF_DELEGATED_SEND_RC_OK: zf_delegated_send_rc = 0;
pub const zf_delegated_send_rc_ZF_DELEGATED_SEND_RC_NOCWIN: zf_delegated_send_rc = 1;
pub const zf_delegated_send_rc_ZF_DELEGATED_SEND_RC_NOWIN: zf_delegated_send_rc = 2;
pub const zf_delegated_send_rc_ZF_DELEGATED_SEND_RC_BAD_SOCKET: zf_delegated_send_rc = 131;
pub const zf_delegated_send_rc_ZF_DELEGATED_SEND_RC_SMALL_HEADER: zf_delegated_send_rc = 132;
pub const zf_delegated_send_rc_ZF_DELEGATED_SEND_RC_SENDQ_BUSY: zf_delegated_send_rc = 133;
pub const zf_delegated_send_rc_ZF_DELEGATED_SEND_RC_NOARP: zf_delegated_send_rc = 134;
pub type zf_delegated_send_rc = ::std::os::raw::c_uint;
extern "C" {
    pub fn zf_delegated_send_prepare(
        ts: *mut zft,
        max_delegated_wnd: ::std::os::raw::c_int,
        cong_wnd_override: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        ds: *mut zf_ds,
    ) -> zf_delegated_send_rc;
}
extern "C" {
    pub fn zf_delegated_send_complete(
        ts: *mut zft,
        iov: *const iovec,
        iovlen: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zf_delegated_send_cancel(ts: *mut zft) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
